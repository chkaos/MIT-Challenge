(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{436:function(t,a,e){"use strict";e.r(a);var s=e(45),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_15-equality"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15-equality"}},[t._v("#")]),t._v(" 15. Equality")]),t._v(" "),e("h3",{attrs:{id:"概要"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概要"}},[t._v("#")]),t._v(" 概要")]),t._v(" "),e("p",[t._v("平等应该是等价关系（反射，对称，传递）。\n相等性和哈希码必须彼此一致，以便使用哈希表（如 HashSet 和 HashMap ）的数据结构可以 正常工作。\n抽象函数是不变数据类型中相等性的基础。\n引用相等是可变数据类型中相等的基础。这是确保时间一致性并避免破坏哈希表的rep不变量的唯一方法。\n平等是实现抽象数据类型的一部分，我们已经了解到ADT对实现我们的三个主要目标的重要性。让我们特别看一下相等性：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("安全的错误: 对于集合和映射之类的集合数据类型，必须正确实现相等和哈希码。编写测试也非常需要。由于Java中的每个对象都继承了 Object 实现，因此不可变类型必须覆盖它们。")])]),t._v(" "),e("li",[e("p",[t._v("容易理解: 阅读我们规范的客户和其他程序员将期望我们的类型实现适当的相等操作，如果不这样做，将会感到惊讶和困惑。")])]),t._v(" "),e("li",[e("p",[t._v("准备改变: 正确地实现 不可变 类型的相等性，可以将引用的相等性与抽象值的相等性区分开来，从而向客户隐藏了有关是否共享值的决策。为 可变 类型选择行为相等而不是观察相等， 有助于避免意外的别名错误。")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);