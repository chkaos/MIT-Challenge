(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{437:function(t,a,r){"use strict";r.r(a);var s=r(45),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"_18-parser-generators"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_18-parser-generators"}},[t._v("#")]),t._v(" 18.Parser Generators")]),t._v(" "),r("h3",{attrs:{id:"語法分析器生成器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#語法分析器生成器"}},[t._v("#")]),t._v(" 語法分析器生成器")]),t._v(" "),r("p",[t._v("解析器生成器将文法作为输入，并自动生成可使用文法解析字符流的源代码。")]),t._v(" "),r("p",[t._v("生成的代码是解析器 ，该解析器 采用字符序列并尝试将序列与语法进行匹配。解析器通常会生成一个 解析树 ，该树 显示语法生成如何扩展为与字符序列匹配的句子。语法分析树的根是语法的起始非终结符。语法分析树的每个节点都扩展为语法的一种形式。在下一节中，我们将了解解析树的实际外观。")]),t._v(" "),r("p",[t._v("解析的最后一步是对该解析树进行一些有用的操作。我们将其转换为递归数据类型的值。递归抽象数据类型通常用于表示某种语言的表达式，例如HTML或Markdown或Java或代数表达式。表示语言表达式的递归抽象数据类型称为 抽象语法树 （AST）。")]),t._v(" "),r("h3",{attrs:{id:"语法分析器生成"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#语法分析器生成"}},[t._v("#")]),t._v(" 语法分析器生成")]),t._v(" "),r("p",[t._v("假设语法文件中没有语法错误，则解析器生成器将在当前文件夹中生成新的源文件生成的代码分为几个协作模块：")]),t._v(" "),r("ul",[r("li",[t._v("词法分析器: 取字符作为输入的流，并且词法令牌作为输出，如 "),r("code",[t._v("NUMBER ， + ，和 (")]),t._v("。")]),t._v(" "),r("li",[t._v("分析器: 采用由词法分析器产生的终端的数据流，并产生一个解析树。")]),t._v(" "),r("li",[t._v("树遍历器: 您可以编写走到解析器生成的解析树代码。")])]),t._v(" "),r("h3",{attrs:{id:"调用语法分析器-遍历解析树-构造一个抽象语法树-处理错误"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#调用语法分析器-遍历解析树-构造一个抽象语法树-处理错误"}},[t._v("#")]),t._v(" 调用语法分析器, 遍历解析树, 构造一个抽象语法树, 处理错误")]),t._v(" "),r("h3",{attrs:{id:"概要"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#概要"}},[t._v("#")]),t._v(" 概要")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("避免错误: 语法是字符串和流的声明性规范，可以由解析器生成器自动实现。与解析手工编写的代码相比，这些规范通常更简单，更直接，更不会出错。")])]),t._v(" "),r("li",[r("p",[t._v("容易明白: 与手写的解析代码相比，语法以紧凑且易于理解的形式捕获序列的形状。")])]),t._v(" "),r("li",[r("p",[t._v("准备好进行更改: 可以轻松地编辑语法，然后通过解析器生成器运行以重新生成解析代码。")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);