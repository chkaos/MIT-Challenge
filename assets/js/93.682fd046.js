(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{470:function(e,n,t){"use strict";t.r(n);var o=t(45),a=Object(o.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_13-disconnected-operation-eventual-consistency"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-disconnected-operation-eventual-consistency"}},[e._v("#")]),e._v(" 13.Disconnected Operation: Eventual Consistency")]),e._v(" "),t("p",[e._v("Managing Update Conflicts in Bayou, a Weakly Connected Replicated\nStorage System Terry, Theimer, Petersen, Demers, Spreitzer, Hauser,\nSOSP 95\nsome material from Flexible Update Propagation for Weakly Consistent\nReplication, SOSP 97")]),e._v(" "),t("p",[e._v('Why this paper?\nEventual consistency is pretty common\ngit, iPhone sync, Dropbox, Amazon Dynamo\nWhy do people like eventual consistency?\nfast read/write of local copy (no primary, no paxos)\ndisconnected operation\nWhat goes wrong?\ndoesn\'t look like "single copy" (no primary, no paxos)\nconflicting writes to different copies\nhow to reconcile them when discovered?\nBayou has the most sophisticated reconciliation story')]),e._v(" "),t("p",[e._v("Paper context:\nEarly 1990s (like Ficus)\nDawn of PDAs, laptops, tablets\nH/W clunky but clear potential\nCommercial devices did not have wireless\nDevices might be off or not have network access\nThis problem has not gone away!\niPhone sync, Dropbox sync, Dynamo")]),e._v(" "),t("p",[e._v("Let's build a conference room scheduler\nOnly one meeting allowed at a time (one room).\nEach entry has a time and a description.\nWe want everyone to end up seeing the same set of entries.")]),e._v(" "),t("p",[e._v("Traditional approach: one server\nServer executes one client request at a time\nChecks for conflicting time, says yes or no\nUpdates DB\nProceeds to next request\nServer implicitly chooses order for concurrent requests")]),e._v(" "),t("p",[e._v("Why aren't we satisfied with central server?\nI want to use scheduler on disconnected iPhone &c\nSo need DB replica in each node.\nModify on any node, as well as read.\nPeriodic connectivity to net.\nPeriodic direct contact with other calendar users (e.g. bluetooth).")]),e._v(" "),t("p",[e._v("Straw man 1: merge DBs.\nSimilar to iPhone calendar sync, or file sync.\nMay need to compare every DB entry -- lots of time and net b/w.\nStill need a story for conflicting entries, i.e. two meetings at same time.\nUser may not be available to decide at time of DB merge.\nSo need automatic reconciliation.")]),e._v(" "),t("p",[e._v('Idea for conflicts: update functions\nApplication supplies a function, not a new value.\nRead current state of DB, decide best change.\nE.g. "Meet at 9 if room is free at 9, else 10, else 11."\nRather than just "Meet at 9"\nFunction can make reconciliation decision for absent user.\nSync exchanges functions, not DB content.')]),e._v(" "),t("p",[e._v("Problem: can't just apply update functions to DB replica\nA's fn: staff meeting at 10:00 or 11:00\nB's fn: hiring meeting at 10:00 or 11:00\nX syncs w/ A, then B\nY syncs w/ B, then A\nWill X put A's meeting at 10:00, and Y put A's at 11:00?")]),e._v(" "),t("p",[e._v("Goal: eventual consistency\nOK for X and Y to disagree initially\nBut after enough syncing, all nodes' DBs should be identical")]),e._v(" "),t("p",[e._v("Idea: ordered update log\nOrdered log of updates at each node.\nSyncing == ensure both nodes have same updates in log.\nDB is result of applying update functions in order.\nSame log => same order => same DB content.")]),e._v(" "),t("p",[e._v("How can nodes agree on update order?\nUpdate ID: <time T, node ID>\nT is creating node's wall-clock time.\nOrdering updates a and b:\na < b if a.T < b.T or (a.T = b.T and a.ID < b.ID)")]),e._v(" "),t("p",[e._v("Example:\n<10,A>: staff meeting at 10:00 or 11:00\n<20,B>: hiring meeting at 10:00 or 11:00\nWhat's the correct eventual outcome?\nthe result of executing update functions in timestamp order\nstaff at 10:00, hiring at 11:00")]),e._v(" "),t("p",[e._v("What DB content before sync?\nA: staff at 10:00\nB: hiring at 10:00\nThis is what A/B user will see before syncing.")]),e._v(" "),t("p",[e._v("Now A and B sync with each other\nEach sorts new entries into its log, order by time-stamp\nBoth now know the full set of updates\nA can just run B's update function\nBut B has "),t("em",[e._v("already")]),e._v(" run B's operation, too soon!")]),e._v(" "),t("p",[e._v('Roll back and replay\nB needs to to "roll back" DB, re-run both ops in the right order\nBig point: the log holds the truth; the DB is just an optimization\nWe will optimize roll-back in a bit')]),e._v(" "),t("p",[e._v('Displayed meeting room calendar entries are "tentative"\nB\'s user saw hiring at 10, then it changed to hiring at 11')]),e._v(" "),t("p",[e._v('Will update order be consistent with wall-clock time?\nMaybe A went first (in wall-clock time) with <10,A>\nNode clocks unlikely to be perfectly synchronized\nSo B could then generate <9,B>\nB\'s meeting gets priority, even though A asked first\nNot "externally consistent"')]),e._v(" "),t("p",[e._v("Will update order be consistent with causality?\nWhat if A adds a meeting,\nthen B sees A's meeting,\nthen B deletes A's meeting.\nPerhaps\n<10,A> add\n<9,B> delete -- B's clock is slow\nNow delete will be ordered before add!")]),e._v(" "),t("p",[e._v("Lamport logical clocks for causal consistency\nWant to timestamp events s.t.\nif node observes E1, then generates E2, then TS(E2) > TS(E1)\nSo all nodes will order E1, then E2\nTmax = highest time-stamp seen from any node (including self)\nT = max(Tmax + 1, wall-clock time) -- to generate a timestamp\nNote properties:\nE1 then E2 on same node => TS(E1) < TS(E2)\nBUT\nTS(E1) < TS(E2) does not imply E1 came before E2")]),e._v(" "),t("p",[e._v("Logical clock solves add/delete causality example\nWhen B sees <10,A>,\nB will set its Tmax to 10, so\nB will generate <11,B> for its delete")]),e._v(" "),t("p",[e._v('Irritating that there could always be a long-delayed update with lower TS\nThat can cause the results of my update to change\nUser can never be sure if meeting time is final!\nWould be nice if updates were eventually "stable"\n=> no changes in update order up to that point\n=> results can never again change -- you know for sure when your meeting is\n=> don\'t have to roll back, re-run committed updates')]),e._v(" "),t("p",[e._v('Bad idea: a fully decentralized "commit" scheme\nProposal: <10,A> is stable if all nodes have seen all updates w/ TS <= 10\nHave sync always send in log order -- "prefix property"\nIf you have seen updates w/ TS > 10 from '),t("em",[e._v("every")]),e._v(" node\nThen you'll never again see one < <10,A>\nSo <10,A> is stable\nWhy doesn't Bayou do this?")]),e._v(" "),t("p",[e._v('How does Bayou commit updates, so that they are stable?\nOne node designated "primary replica".\nIt marks each update it receives with a permanent CSN.\nCommit Sequence Number.\nThat update is committed.\nSo a complete time stamp is <CSN, local-time, node-id>\nUncommitted updates come after all committed updates.\nCSN notifications are synced between nodes.\nThe CSNs define a total order for committed updates.\nAll nodes will eventually agree on it.')]),e._v(" "),t("p",[e._v("Will commit order match tentative order?\nOften.\nSyncs send in log order (prefix property)\nIncluding updates learned from other nodes.\nSo if A's update log says\n<-,10,X>\n<-,20,A>\nA will send both to primary, in that order\nPrimary will assign CSNs in that order\nCommit order will, in this case, match tentative order")]),e._v(" "),t("p",[e._v("Will commit order always match tentative order?\nNo: primary may see newer updates before older ones.\nA has just: <-,10,A> W1\nB has just: <-,20,B> W2\nIf C sees both, C's order: W1 W2\nB syncs with primary, gets CSN=5.\nLater A syncs w/ primary, gets CSN=6.\nWhen C syncs w/ primary, order will change to W2 W1\n<5,20,B> W1\n<6,10,A> W2\nSo: committing may change order.")]),e._v(" "),t("p",[e._v("Committing allows app to tell users which calendar entries are stable.\nA stable meeting room time is final.")]),e._v(" "),t("p",[e._v("Nodes can discard committed updates.\nInstead, keep a copy of the DB as of the highest known CSN.\nRoll back to that DB when replaying tentative update log.\nNever need to roll back farther.\nPrefix property guarantees seen CSN=x => seen CSN<x.\nNo changes to update order among committed updates.")]),e._v(" "),t("p",[e._v("How do I sync if I've discarded part of my log?\nSuppose I've discarded all updates with CSNs.\nI keep a copy of the stable DB reflecting just discarded entries.\nWhen I propagate to node X:\nIf node X's highest CSN is less than mine,\nI can send him my stable DB reflecting just committed updates.\nNode X can use my DB as starting point.\nAnd X can discard all CSN log entries.\nThen play his tentative updates into that DB.\nIf node X's highest CSN is greater than mine,\nX doesn't need my DB.\nIn practice, Bayou nodes keep the last few committed updates.\nTo reduce chance of having to send whole DB during sync.")]),e._v(" "),t("p",[e._v("How to sync?\nA sending to B\nNeed a quick way for B to tell A what to send\nCommitted updates easy: B sends its CSN to A\nWhat about tentative updates?\nA has:\n<-,10,X>\n<-,20,Y>\n<-,30,X>\n<-,40,X>\nB has:\n<-,10,X>\n<-,20,Y>\n<-,30,X>\nAt start of sync, B tells A \"X 30, Y 20\"\nSync prefix property means B has all X updates before 30, all Y before 20\nA sends all X's updates after <-,30,X>, all Y's updates after <-,20,X>, &c\nThis is a version vector -- it summarize log content\nIt's the \"F\" vector in Figure 4\nA's F: [X:40,Y:20]\nB's F: [X:30,Y:20]")]),e._v(" "),t("p",[e._v("How could we cope with a new server Z joining the system?\nCould it just start generating writes, e.g. <-,1,Z> ?\nAnd other nodes just start including Z in VVs?\nIf A syncs to B, A has <-,10,Z>, but B has no Z in VV\nA should pretend B's VV was [Z:0,...]")]),e._v(" "),t("p",[e._v("What happens when Z retires (leaves the system)?\nWe want to stop including Z in VVs!\nHow to announce that Z is gone?\nZ sends update <-,?,Z> \"retiring\"\nIf you see a retirement update, omit Z from VV\nHow to deal with a VV that's missing Z?\nIf A has log entries from Z, but B's VV has no Z entry:\ne.g. A has <-,25,Z>, B's VV is just [A:20, B:21]\nMaybe Z has retired, B knows, A does not\nMaybe Z is new, A knows, B does not\nNeed a way to disambiguate: Z missing from VV b/c new, or b/c retired?")]),e._v(" "),t("p",[e._v("Bayou's retirement plan\nZ joins by contacting some server X\nZ's ID is <Tz,X>\nTz is X's logical clock as of when Z joined\nX issues <-,Tz,X>:\"new server Z\"")]),e._v(" "),t("p",[e._v("How does ID=<Tz,X> scheme help disambiguate new vs forgotten?\nSuppose Z's ID is <20,X>\nA syncs to B\nA has log entry from Z <-,25,<20,X>>\nB's VV has no Z entry\nOne case:\nB's VV: [X:10, ...]\n10 < 20 implies B hasn't yet seen X's \"new server Z\" update\nThe other case:\nB's VV: [X:30, ...]\n20 < 30 implies B once knew about Z, but then saw a retirement update")]),e._v(" "),t("p",[e._v("Let's step back")]),e._v(" "),t("p",[e._v("Is eventual consistency a useful idea?\nYes: people want fast writes to local copies\niPhone sync, Dropbox, Dynamo, Riak, Cassandra, &c")]),e._v(" "),t("p",[e._v("Are update conflicts a real problem?\nYes -- all systems have some more or less awkward solution")]),e._v(" "),t("p",[e._v("Is Bayou's complexity warranted?\nI.e. log of update functions, version vectors, tentative operations\nOnly critical if you want peer-to-peer sync\nI.e. both disconnected operation AND ad-hoc connectivity\nOnly tolerable if humans are main consumers of data\nOtherwise you can sync through a central server (iPhone, Dropbox)\nOr read locally but send updates through a master (PNUTS, Spanner)")]),e._v(" "),t("p",[e._v("But there's are good ideas for us to learn from Bayou\nUpdate functions for automatic application-driven conflict resolution\nOrdered update log is the real truth, not the DB\nLogical clock for causal consistency")])])}),[],!1,null,null,null);n.default=a.exports}}]);