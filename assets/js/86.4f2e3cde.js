(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{463:function(e,a,n){"use strict";n.r(a);var t=n(45),o=Object(t.a)({},(function(){var e=this,a=e.$createElement,n=e._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_5-fault-tolerance-paxos"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-fault-tolerance-paxos"}},[e._v("#")]),e._v(" 5: Fault Tolerance:Paxos")]),e._v(" "),n("p",[e._v("From Paxos Made Simple, by Leslie Lamport, 2001")]),e._v(" "),n("p",[e._v("starting a new group of lectures on stronger fault tolerance\ntoday:\ncleaner approach to replication: RSM via Paxos\nyou'll need Paxos for Lab 3\nsubsequent lectures:\nimproved Paxos-like protocols (Raft)\nusing replication in systems (Harp, later Spanner)")]),e._v(" "),n("p",[e._v("recall: RSM\nmaintain replicas by executing operations in the same order\nrequires all replicas to agree on the (set and) order of operations\nthe point: if one server fails, can use other servers, which have state")]),e._v(" "),n("p",[e._v("Lab 2 critique\nprimary/backup with viewserver\npro:\nonly two k/v servers needed to tolerate one failure\nhandles network partition correctly (viewserver's partition wins)\ncon:\nviewserver is single point of failure")]),e._v(" "),n("p",[e._v("network partition is the knottiest problem here\nover a network, one cannot distinguish:\nprimary has crashed,\nso backup should take over\nprimary is up and serving but net is partitioned,\nso backup should "),n("em",[e._v("not")]),e._v(" take over\nviewserver solves this BUT is not fault-tolerant")]),e._v(" "),n("p",[e._v("paxos lets us build replication schemes that:\nhandle partition correctly\nhave no single point of failure")]),e._v(" "),n("p",[e._v("why paxos specifically?\nthere are better protocols (Viewstamped Replication, Raft, ZAB)\npaxos is simple (as these things go)\nmany other protocols are easy to view as variants of Paxos\nPaxos (and variants) are used a lot in real systems")]),e._v(" "),n("p",[e._v("there are two hard topics here")]),e._v(" "),n("ol",[n("li",[e._v("how does Paxos work?")]),e._v(" "),n("li",[e._v("how to use Paxos sensibly in a real system?\n#1 takes thought but is pretty well scoped\n#2 has been MUCH HARDER for people to figure out\nI'll talk about #2 first, for context")])]),e._v(" "),n("p",[e._v("Paxos-based replication -- the big picture:\n[diagram: clients, replicas, log in each replica, k/v layer, paxos layer]\nno viewserver\nthree replicas\nclients can send RPCs to any replica (not just primary)\nserver appends each client op to a replicated "),n("em",[e._v("log")]),e._v(" of operations\nPut, Get, Append\nnumbered log entries -- instances -- seq\nPaxos agreement on content of each log entry\nnote: each instance (log entry) is an entirely separate Paxos agreement\nwith entirely separate proposal numbers")]),e._v(" "),n("p",[e._v("what does Paxos provide?\nLab 3 interface on each server:\nStart(seq, v) -- to propose v as value for instance seq\nfate, v := Status(seq) -- to find out the agreed value for instance seq\ncorrectness:\nif agreement reached, all agreeing servers agree on same value\ncorollary: once any agreement reached, never changes its mind\ncritical since, after agreement, servers may update state or reply to clients\n(may not agree if too many lost messages, crashed servers)\nfault-tolerance:\ncan tolerate non-reachability of a minority of servers\nliveness:\nwill reach agreement when a majority can communicate for long enough")]),e._v(" "),n("p",[e._v("example:\nclient sends Put(a,b) to S1\nS1 picks log entry 3\nS1 uses Paxos to get all servers to agree that entry 3 holds Put(a,b)")]),e._v(" "),n("p",[e._v("example:\nclient sends Get(a) to S2\nS2 picks log entry 4\nS2 uses Paxos to get all servers to agree that entry 4 holds Get(a)\nS2 scans log up to entry 4 to find latest Put(a,...)\nS2 replies with that value\n(S2 can cache content of DB up through last log scan)")]),e._v(" "),n("p",[e._v("why a log?\nwhy not require all replicas to agree on each op in lock-step?\ndoesn't matter if the state is small: can agree on entire state\nlog is a big win if state is very large; log describes changes\nlog helps replicas catch up\nif slow, miss messages, crash and restart")]),e._v(" "),n("p",[e._v("summary of how to use Paxos for RSM:\na log of Paxos instances\neach instance's value is a client command\ndifferent instances' Paxos agreements are independent\nthis is how Lab 3B works")]),e._v(" "),n("p",[e._v("now let's switch to how a single Paxos agreement works")]),e._v(" "),n("p",[e._v("agreement is hard (1):\nmay be multiple proposals for the op in a particular log slot\nSx may initially hear of one, Sy may hear of another\nclearly Sx or Sy must change its mind\nthus: multiple rounds, tentative initially\nhow do we know when agreement is permanent -- no longer tentative?")]),e._v(" "),n("p",[e._v("agreement is hard (2):\nif S1 and S2 are happy with a value, and S3 and S4 don't respond, are we done?\nagreement has to be able to complete even w/ failed servers\nwe can't distinguish failed server from network partition\nso maybe S3/S4 are partitioned and have \"agreed\" on a different value!")]),e._v(" "),n("p",[e._v("two main ideas in Paxos:")]),e._v(" "),n("ol",[n("li",[e._v("many rounds may be required but they will converge on one value")]),e._v(" "),n("li",[e._v('a majority is required for agreement -- prevent "split brain"\na key point: any two majorities overlap\nso any later majority will share at least one server w/ any earlier majority\nso any later majority can find out what earlier majority decided')])]),e._v(" "),n("p",[e._v("Paxos sketch\neach server consists of three logical entities:\nproposer\nacceptor\nlearner\nmay be more than one proposer\nif multiple clients submit requests at the same time to diff servers\neach proposer wants to get agreement on its value\nproposer contacts acceptors, tries to assemble a majority\nmight not get majority -> new round")]),e._v(" "),n("p",[e._v("basic Paxos exchange:\nproposer        acceptors\nprepare(n) ->\n<- prepare_ok(n, n_a, v_a)\naccept(n, v') ->\n<- accept_ok(n)\ndecided(v') ->")]),e._v(" "),n("p",[e._v('why n?\nto distinguish among multiple rounds, e.g. proposer crashes, simul props\nwant later rounds to supersede earlier ones\nnumbers allow us to compare early/late\nn values must be unique and roughly follow time\nn = <time, server ID>\ne.g., ID can be server\'s IP address\n"round" is the same as "proposal" but completely different from "instance"\nround/proposal numbers are WITHIN a particular instance')]),e._v(" "),n("p",[e._v("definition: server S accepts n/v\nS responded accept_ok to accept(n, v)")]),e._v(" "),n("p",[e._v("definition: n/v is chosen\na majority of servers accepted n/v")]),e._v(" "),n("p",[e._v('the crucial property:\nif a value was chosen, any subsequent choice must be the same value\ni.e. protocol must not change its mind\nmaybe a different proposer &c, but same value!\nthis allows us to freely start new rounds after crashes &c\nAND it allows a server to safely execute a chosen command, or reply to client\ntricky b/c "chosen" is system-wide property\ne.g. majority accepts, then proposer crashes\nno server can tell locally that agreement was reached')]),e._v(" "),n("p",[e._v("so:\nproposer doesn't send out value with prepare\nacceptors send back any value they have already accepted\nif there is one, proposer proposes that value\nto avoid changing an existing choice\nif no value already accepted,\nproposer can propose any value (e.g. a client request)\nproposer must get prepare_ok from majority\nto guarantee intersection with any previous majority,\nto guarantee proposer hears of any previously chosen value")]),e._v(" "),n("p",[e._v("now the protocol -- see the handout")]),e._v(" "),n("p",[e._v("proposer(v):\nchoose n, unique and higher than any n seen so far\nsend prepare(n) to all servers including self\nif prepare_ok(n, n_a, v_a) from majority:\nv' = v_a with highest n_a; choose own v otherwise\nsend accept(n, v') to all\nif accept_ok(n) from majority:\nsend decided(v') to all")]),e._v(" "),n("p",[e._v("acceptor state:\nmust persist across reboots\nn_p (highest prepare seen)\nn_a, v_a (highest accept seen)")]),e._v(" "),n("p",[e._v("acceptor's prepare(n) handler:\nif n > n_p\nn_p = n\nreply prepare_ok(n, n_a, v_a)\nelse\nreply prepare_reject")]),e._v(" "),n("p",[e._v("acceptor's accept(n, v) handler:\nif n >= n_p\nn_p = n\nn_a = n\nv_a = v\nreply accept_ok(n)\nelse\nreply accept_reject")]),e._v(" "),n("p",[e._v('example 1 (normal operation):\nS1, S2, S3\nbut S3 is dead or slow\nS1 starts proposal, n=1 v=A\nS1: p1    a1A    dA\nS2: p1    a1A    dA\nS3: dead...\n"p1" means Sx receives prepare(n=1)\n"a1A" means Sx receives accept(n=1, v=A)\n"dA" means Sx receives decided(v=A)\nthese diagrams are not specific about who the proposer is\nit doesn\'t really matter\nthe proposers are logically separate from the acceptors\nwe only care about what acceptors saw and replied')]),e._v(" "),n("p",[e._v("Note proposer only ever needs to wait for a majority of the servers\nso we can continue even though S3 was down\nproposer must not wait forever for any one acceptor's response")]),e._v(" "),n("p",[e._v("What would happen if network partition?\nI.e. S3 was alive and had a proposed value B\nS3's prepare would not assemble a majority")]),e._v(" "),n("p",[e._v("the homework question:\nHow does Paxos ensure that the following sequence of events can't\nhappen? What actually happens, and which value is ultimately chosen?\nproposer 1 wants v=X, crashes after sending two accepts\nproposer 2 wants v=Y\nS1: p1 a1X\nS2: p1     p2 a2?\nS3: p1 a1X p2 a2?\nS3's prepare_ok to proposer 2 really included \"X\"\nthus a2X, and so no problem\nthe point:\nif the system has already reached agreement, majority will know value\nany new majority of prepares will intersect that majority\nso subsequent proposer will learn of already-agreed-on value\nand send it in accept msgs")]),e._v(" "),n("p",[e._v("example 2 (concurrent proposers):\nS1 starts proposing n=10\nS1 sends out just one accept v=X\nS3 starts proposing n=11\nbut S1 does not receive its proposal\nS3 only has to wait for a majority of proposal responses\nS1: p10 a10X\nS2: p10        p11\nS3: p10        p11  a11Y\nS1 is still sending out accept messages...\nhas a value been chosen?\ncould it go either way (X or Y) at this point?\nwhat will happen?\nwhat will S2 do if it gets a10X accept msg from S1?\nwhat will S1 do if it gets a11Y accept msg from S3?\nwhat if S3 were to crash at this point (and not restart)?")]),e._v(" "),n("p",[e._v("how about this:\nS1: p10  a10X               p12\nS2: p10          p11  a11Y"),n("br"),e._v('\nS3: p10          p11        p12   a12X\nhas the system agreed to a value at this point?\nafter all, a majority have accepted value "X"')]),e._v(" "),n("p",[e._v("what's the commit point?\ni.e. exactly when has agreement been reached?\ni.e. at what point might a server have executed the command?\nafter a majority has the same v_a? no -- why not?  above counterexample\nafter a majority has the same v_a/n_a? yes -- why sufficient?  sketch:\nsuppose majority has same v_a/n_a\nacceptors will reject accept() with lower n\nfor any higher n: prepare's must have seen our majority v_a/n_a (overlap)")]),e._v(" "),n("p",[e._v("why does the proposer need to pick v_a with highest n_a?\nS1: p10  a10A               p12\nS2: p10          p11  a11B"),n("br"),e._v("\nS3: p10          p11  a11B  p12   a12?\nn=11 already agreed on vB\nn=12 sees both vA and vB, but must choose vB\nwhy: two cases:")]),e._v(" "),n("ol",[n("li",[e._v("there was a majority before n=11\nn=11's prepares would have seen value and re-used it\nso it's safe for n=12 to re-use n=11's value")]),e._v(" "),n("li",[e._v("there was not a majority before n=11\nn=11 might have obtained a majority\nso it's required for n=12 to re-use n=11's value")])]),e._v(" "),n("p",[e._v("why does prepare handler check that n > n_p?\nit doesn't have to: a proposer that fails the check in\nprepare handler will fail same check in accept handler")]),e._v(" "),n("p",[e._v("why does accept handler check n >= n_p?\nto ensure later proposer sees any possible chosen value\nby preventing acceptance of old value once an acceptor\nhas responded to new proposer's prepare\nw/o n >= n_p check, you could get this bad scenario:\nS1: p1 p2 a1A\nS2: p1 p2 a1A a2B\nS3: p1 p2     a2B\noops, for a while A was chosen, then changed to B!")]),e._v(" "),n("p",[e._v("why does accept handler update n_p = n?\nrequired to prevent earlier n's from being accepted\nserver can get accept(n,v) even though it never saw prepare(n)\nwithout n_p = n, can get this bad scenario:\nS1: p1    a2B a1A p3 a3A\nS2: p1 p2         p3 a3A\nS3:    p2 a2B\noops, for a while B was chosen, then changed to A!")]),e._v(" "),n("p",[e._v("what if proposer S2 chooses n < S1's n?\ne.g. S2 didn't see any of S1's messages\nS2 won't make progress, so no correctness problem")]),e._v(" "),n("p",[e._v("what if an acceptor crashes after receiving accept?\nS1: p1  a1X\nS2: p1  a1X reboot  p2  a2?\nS3: p1              p2  a2?\nthe story:\nS2 is the only intersection between p1's and p2's majorities\nthus the only evidence that Paxos already chose X\nso S2 "),n("em",[e._v("must")]),e._v(" return X in prepare_ok\nso S2 must be able to recover its pre-crash state\nthus: if S2 wants to re-join this Paxos instance,\nit must remember its n_p/v_a/n_a on disk.")]),e._v(" "),n("p",[e._v("what if an acceptor reboots after sending prepare_ok?\ndoes it have to remember n_p on disk?\nif n_p not remembered, this could happen:\nS1: p10            a10X\nS2: p10 p11 reboot a10X a11Y\nS3:     p11             a11Y\n11's proposer did not see value X, so 11 proposed its own value Y\nbut just before that, X had been chosen!\nb/c S2 did not remember to ignore a10X")]),e._v(" "),n("p",[e._v("can Paxos get stuck?\nyes, if there is not a majority that can communicate\nhow about if a majority is available?\nif proposers immediately retry w/ higher n after accept_reject,\nthey can all keep each other from getting accepts accepted\nso don't retry immediately!\npause a random amount of time, then re-try")])])}),[],!1,null,null,null);a.default=o.exports}}]);