(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{464:function(e,n,t){"use strict";t.r(n);var o=t(45),a=Object(o.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_6-fault-tolerance-raft"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-fault-tolerance-raft"}},[e._v("#")]),e._v(" 6: Fault Tolerance:Raft")]),e._v(" "),t("p",[e._v("this lecture\nlarger topic is fault tolerance via replicated state machines\nRaft -- a much more complete design than straight Paxos")]),e._v(" "),t("p",[e._v("Russ Cox of Google will talk about Go on Thursday\nsubmit your questions early, so we can get them to Russ")]),e._v(" "),t("p",[e._v("Raft overview\nclients -> leader -> followers -> logs -> execution")]),e._v(" "),t("p",[e._v("Raft vs Paxos?\nOur use of Paxos:\nagrees separately on each client operation\nRaft:\nagrees on each new leader (and on tail of log)\nagreement not required for most client operations\nRaft is Paxos optimized for log appends (more or less)\nwhy Raft-style leader?\nno dueling proposers (unless leader fails)\nfewer messages, less complexity (unless leader fails)\nwell-defined notion of one log being more complete than another\nsimplifies switching leaders (and maybe crash recovery)")]),e._v(" "),t("p",[e._v("what about understandability?\nyou must decide for yourself\nstraight Paxos is simpler than Raft\nbut straight Paxos is too simple for practical replication\neveryone extends it in their own way\nand ends up with something more or less like Raft\nPaxos+log+leader probably not simpler than Raft\nthough presumably depends on which Paxos variant you choose")]),e._v(" "),t("p",[e._v("is more direct use of Paxos (like Lab 3) ever a win?\ni.e. is a Raft-style leader ever a bad idea?\ngeographically spread peers\na single leader would be far from some clients\nsome peers would be slow to other peers (paxos tolerates lag)")]),e._v(" "),t("p",[e._v("let's start w/ Raft w/ no leader change\nfor now, reliable leader\nfollowers may be slow or unreachable (but they do not lose state)\nwhat do we want?\n1. tolerate a minority of failed followers\n2. converge on same log`\nsince replication requires same order of execution\n3. execute only when entry cannot be lost (committed)\nsince cannot easily un-do execution or reply to client\nidea for ensuring identical log:\nleader sends log entry, index, and info about "),t("em",[e._v("previous")]),e._v(" entry\nclient can reject (e.g I don't have previous entry!)\nleader backs up for that follower, sends earlier entries\n-> leader forces followers' logs to be identical to leader's\nidea for execution:\nidea #1 means leader knows follower is identical up to some point\nonce a majority are identical up to a point,\nleader sends that out as commit point,\neveryone can execute through that point,\nleader can reply to clients")]),e._v(" "),t("p",[e._v('what to do if the leader crashes?\nother servers time out (no AppendEntries "heart-beats" for a while)\nchoose a new leader!\nRaft divides time into terms\nmost terms have a leader')]),e._v(" "),t("p",[e._v("what are the dangers in transition to a new leader?\ntwo leaders\nno leader\nmight forget an executed log entry\nlogs might end up different (diverge)")]),e._v(" "),t("p",[e._v("leader election first, then log consistency at term boundary")]),e._v(" "),t("p",[e._v("how to ensure at most one leader in a term?\n(look at Figure 2, RequestVote RPC, and Rules for Servers)\nleader must get votes from a majority of servers\nserver can cast only one vote per term\nthus at most one server can think it has won\nwhy a majority?\nthe answer is always the same!\nallows fault tolerance (failure of minority doesn't impede progress)\nprevents split brain (at most one candidate can get a majority)\nensures overlap (at least one in majority has every previously committed log entry)")]),e._v(" "),t("p",[e._v("could election fail to choose any leader?\nyes!")]),e._v(" "),t("blockquote",[t("p",[e._v("= 3 candidates split the vote evenly\nor even # of live servers, two candidates each get half")])]),e._v(" "),t("p",[e._v("what happens after an election in which no-one gets majority?\ntimeout, increment term, new election\nhigher term takes precedence, candidates for older terms quit\nnote: timeout must be longer than it takes to complete election!\nnote: this means some terms may have no leader, no log entries")]),e._v(" "),t("p",[e._v("how does Raft reduce chances of election failure due to split vote?\neach server delays a random amount of time before starting candidacy\nwhy is the random delay useful?\n[diagram of times at which servers' delays expire]\none will choose lowest random delay\nhopefully enough time to elect before next delay expires")]),e._v(" "),t("p",[e._v("how to choose the random delay range?\ntoo short: 2nd candidate starts before first finishes\ntoo long: system sits idle for too long after leader fails\na rough guide:\nsuppose it takes 10ms to complete an unopposed election\nand there are five servers\nwe want delays to be separated by (say) 20ms\nso random delay from 0 to 100 ms\nplus a few multiples of leader heartbeat interval")]),e._v(" "),t("p",[e._v("remember this random delay idea!\nit's a classic scheme for decentralized soft election; e.g. ethernet")]),e._v(" "),t("p",[e._v("Raft's elections follow a common pattern: separation of safety from progress\n"),t("em",[e._v("hard")]),e._v(" mechanisms ensure < 2 leaders in one term\nproblem: elections can fail (e.g. 3-way split)\nsolution: always safe to start a new election in a new term\nproblem: repeated elections can prevent any work getting done\nsolution: "),t("em",[e._v("soft")]),e._v(" mechanisms reduce probability of wasted elections\nheartbeat from leader (remind servers not to start election)\ntimeout period (don't start election too soon)\nrandom delays (give one leader time to be elected)")]),e._v(" "),t("p",[e._v("what if old leader isn't aware a new one is elected?\nperhaps b/c old leader didn't see election messages\nnew leader means a majority of servers have incremented currentTerm\nso old leader (w/ old term) can't get majority for AppendEntries\nthough a minority may accept old server's log entries...\nso logs may diverge at end of old term...")]),e._v(" "),t("p",[e._v("now let's switch topics to data handling at term boundaries")]),e._v(" "),t("p",[e._v("what do we want to ensure?\neach server executes the same client cmds, in the same order\ni.e. if any server executes, then no server executes something\nelse for that log entry\nas long as single leader, we've already seen it makes logs identical\nwhat about when leader changes?")]),e._v(" "),t("p",[e._v("what's the danger?\nleader of term 3 crashed while sending AppendEntries\nS1: 3\nS2: 3 3\nS3: 3 3\nS2 and S3 might have executed; does Raft preserve it?\nmay be a series of crashes, e.g.\nS1: 3\nS2: 3 3 4\nS3: 3 3 5\nthus diff entries for the same index!")]),e._v(" "),t("p",[e._v("roll-back is a big hammer -- forces leader's log on everyone\nin above examples, whoever is elected imposes log on everyone\nexample:\nS3 is chosen as new leader for term 6\nS3 wants to send out a new entry (in term 6)\nAppendEntries says previous entry must have term 5\nS2 replies false (AppendEntries step 2)\nS3 decrements nextIndex[S2]\nAppendEntries for the term=5 op, saying prev has term=3\nS2 deletes op from term 4 (AppendEntries step 3)\n(and S1 rejects b/c it doesn't have anything in that entry)")]),e._v(" "),t("p",[e._v("ok, leader will force its own log on followers\nbut that's not enough!\ncan roll-back delete an executed entry?")]),e._v(" "),t("p",[e._v("when is a log entry executed?\nwhen leader advances commitIndex/leaderCommit\nwhen a majority match the leader up through this point")]),e._v(" "),t("p",[e._v("could new leader roll back executed entries from end of previous term?\ni.e. could an executed entry be missing from the new leader's log?\nRaft needs to ensure new leader's log contains every potentially executed entry\ni.e. must forbid election of server who might be missing an executed entry")]),e._v(" "),t("p",[e._v('what are the election rules?\nFigure 2 says only vote if candidate\'s log "at least as up to date"\nSo leader will be at least as up to date as a majority')]),e._v(" "),t("p",[e._v('what does "at least as up to date" mean?\ncould it mean log is >= length?\nno; example:\nS1: 5 6 7\nS2: 5 8\nS3: 5 8\nfirst, could this scenario happen? how?\nS1 leader in epoch 6; crash+reboot; leader in epoch 7; crash and stay down\nboth times it crashed after only appending to its own log\nS2 leader in epoch 8, only S2+S3 alive, then crash\nwho should be next leader?\nS1 has longest log, but entry 8 is committed !!!\nRaft adopts leader\'s log, so S1 as leader -> un-commit entry 8\nincorrect since S2 may have replied to client\nso new leader can only be one of S2 or S3\ni.e. the rule cannot be simply "longest log"')]),e._v(" "),t("p",[e._v('end of 5.4.1 explains "at least as up to date" voting rule\ncompare last entry\nhigher term wins\nif equal terms, longer log wins')]),e._v(" "),t("p",[e._v("so:\nS1 can't get any vote from S2 or S3, since 7 < 8\nS1 will vote for either S2 or S3, since 8 > 7\nS1's operations from terms 6 and 7 will be discarded!\nok since no majority -> not executed -> no client reply")]),e._v(" "),t("p",[e._v('the point:\n"at least as up to date" rule causes new leader to have all executed\nentries in its log\nso new leader won\'t roll back any executed operation\nsimilar to Paxos: new round ends up using chosen value (if any) of prev round')]),e._v(" "),t("p",[e._v('The Question\nfigure 7, which of a/d/f could be elected?\ni.e. majority of votes from "less up to date" servers?')]),e._v(" "),t("p",[e._v('the most subtle thing about Raft (figure 8)\nnot 100% true that a log entry on a majority is committed\ni.e. will never be forgotten\nfigure 8 describes an exception\nS1: 1 2 4\nS2: 1 2\nS3: 1 2\nS4: 1\nS5: 1 3\nS1 was leader in term 2, sends out two copies of 2\nS5 leader in term 3\nS1 in term 4, sends one more copy of 2 (b/c S3 rejected op 4)\nwhat if S5 now becomes leader?\nS5 can get a majority (w/o S1)\nS5 will roll back 2 and replace it with 3\ncould 2 have executed?\nit is on a majority...\nso could S1 have mentioned it in leaderCommit after majority?\nno! very end of Figure 2 says "log[N].term == currentTerm"\nand S1 was in term 4 when sending 3rd copy of 2\nwhat\'s Raft\'s actual commit point?\nbottom-right of page 310\n"committed once the leader that created the entry has replicated on majority"\nand commit point of one entry commits all before it\nwhich is how 2 '),t("em",[e._v("could")]),e._v(" have committed if S1 hadn't lost leadership")]),e._v(" "),t("p",[e._v("another topic: configuration change (Section 6)\nconfiguration = set of servers\nhow does Raft change the set of servers?\ne.g. every few years might want to retire some, add some\nor move all at once to an entirely new set of server\nor increase/decrease the number of servers")]),e._v(" "),t("p",[e._v("how might a "),t("em",[e._v("broken")]),e._v(" configuration change work?\neach server has the list of servers in the current config\nchange configuation by changing lists, one by one\nexample: want to replace S3 with S4\nS1: 1,2,3  1,2,4\nS2: 1,2,3  1,2,3\nS3: 1,2,3  1,2,3\nS4: 1,2,4  1,2,4\nOOPS!\nnow "),t("em",[e._v("two")]),e._v(" disjoint group/leaders can form:\nS2 and S3 (who know nothing of new config)\nS1 and S4\nboth can process client requests, so split brain")]),e._v(" "),t("p",[e._v('Raft configuration change\nidea: "join consensus" stage that includes '),t("em",[e._v("both")]),e._v(" old and new configuration\nleader of old group logs entry that switches to joint consensus\nduring joint consensus, leader separately logs in old and new\ni.e. "),t("em",[e._v("two")]),e._v(" log and "),t("em",[e._v("two")]),e._v(" agreements on each log entry\nthis will force new servers to catch up\nand force new and old logs to be the same\nafter majority of old and new have switched to joint consensus,\nleader logs entry that switches to final configuration\nS1: 1,2,3  1,2,3+1,2,4\nS2: 1,2,3\nS3: 1,2,3\nS4:        1,2,3+1,2,4\nif crash but new leader didn't see the switch to joint consensus,\nthen old group will continue, no switch, but that's OK\nif crash and new leader did see the switch to joint consensus,\nit will complete the configuration change")]),e._v(" "),t("p",[e._v("performance\nno numbers on how fast it can process requests\nwhat are the bottlenecks likely to be?\ndisk:\nneed to write disk for client data durability, and for protocol promises\nwrite per client request? so 100 per second?\ncould probably batch and get 10,000 to 100,000\nnet: a few message exchanges per client request\n10s of microseconds for local LAN message exchange?\nso 100,000 per second?")]),e._v(" "),t("p",[e._v("Thursday: Russ Cox of Google on Go")]),e._v(" "),t("p",[e._v("next week: use of a Raft-like protocol in a complex application")])])}),[],!1,null,null,null);n.default=a.exports}}]);