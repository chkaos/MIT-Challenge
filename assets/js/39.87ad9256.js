(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{410:function(e,t,a){"use strict";a.r(t);var n=a(45),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"_9-table-doubling-karp-rabin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-table-doubling-karp-rabin"}},[e._v("#")]),e._v(" 9 Table Doubling && Karp Rabin")]),e._v(" "),a("h3",{attrs:{id:"table-doubling"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#table-doubling"}},[e._v("#")]),e._v(" Table Doubling")]),e._v(" "),a("h4",{attrs:{id:"insert"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#insert"}},[e._v("#")]),e._v(" insert")]),e._v(" "),a("p",[e._v("随着元素插入, 哈希表的预留空间不足的话. 每个位置的链表长度会增加, 哈希表各种操作的时间复杂度不将再是常量.")]),e._v(" "),a("p",[e._v("所以必须有方法在元素插入的同时动态扩/缩容. 使得 m 既不过小也不浪费.")]),e._v(" "),a("p",[e._v("复杂度O(n+m+m')n遍历哈希表元素 + m遍历插槽 + m'构建新表")]),e._v(" "),a("p",[e._v("步骤")]),e._v(" "),a("ol",[a("li",[e._v("分配内存")]),e._v(" "),a("li",[e._v("创建table of new size")]),e._v(" "),a("li",[e._v("build new hash function")]),e._v(" "),a("li",[e._v("rehash: 将已存在的元素插入到新哈希表")])]),e._v(" "),a("p",[e._v("插入个数分析\nm+1 : 每次插入的cost为O(n^2)\n2m: 每次插入的cost为O(n), 摊销后cost约等于为O(1)")]),e._v(" "),a("p",[e._v("尽管对现有哈希表使用"),a("code",[e._v("Table Doubling")]),e._v("能使插入操作时间复杂度剧增, 所以我们需要"),a("code",[e._v("amortization")])]),e._v(" "),a("h4",{attrs:{id:"delete"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#delete"}},[e._v("#")]),e._v(" delete")]),e._v(" "),a("p",[e._v("删除操作分析\n1.如果 m = n/2 则缩小一半 每次删除的cost为O(n)\n2.如果 m = n/4 则缩小一半 摊销后的cost为O(1)  (n <= m <= 4n)")]),e._v(" "),a("p",[e._v("一般来说插入数为2或其他常数, 删除常数比插入数稍大;")]),e._v(" "),a("h3",{attrs:{id:"amortization-平摊化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#amortization-平摊化"}},[e._v("#")]),e._v(" amortization 平摊化")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://stackoverflow.com/questions/200384/constant-amortized-time",target:"_blank",rel:"noopener noreferrer"}},[e._v("平摊化解释"),a("OutboundLink")],1)]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Amortised time explained in simple terms:\n\nIf you do an operation say a million times, you don't really care about the worst-case or the best-case of that operation - what you care about is how much time is taken in total when you repeat the operation a million times.\n\nSo it doesn't matter if the operation is very slow once in a while, as long as \"once in a while\" is rare enough for the slowness to be diluted away. Essentially amortised time means \"average time taken per operation, if you do many operations\". Amortised time doesn't have to be constant; you can have linear and logarithmic amortised time or whatever else.\n\nLet's take mats' example of a dynamic array, to which you repeatedly add new items. Normally adding an item takes constant time (that is, O(1)). But each time the array is full, you allocate twice as much space, copy your data into the new region, and free the old space. Assuming allocates and frees run in constant time, this enlargement process takes O(n) time where n is the current size of the array.\n\nSo each time you enlarge, you take about twice as much time as the last enlarge. But you've also waited twice as long before doing it! The cost of each enlargement can thus be \"spread out\" among the insertions. This means that in the long term, the total time taken for adding m items to the array is O(m), and so the amortised time (i.e. time per insertion) is O(1).\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br")])]),a("p",[e._v("简单讲就是将一次高额的操作成本分摊到多次操作上, 可用月租类比->摊销复杂度;")]),e._v(" "),a("h3",{attrs:{id:"string-matching-查看子串问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-matching-查看子串问题"}},[e._v("#")]),e._v(" String Matching 查看子串问题")]),e._v(" "),a("p",[e._v("字符串"),a("code",[e._v("T")]),e._v("和子串"),a("code",[e._v("S")]),e._v(", 各自长度为"),a("code",[e._v("t")]),e._v(","),a("code",[e._v("s")]),e._v("\n普通循环: 循环次数为 t - s, 复杂度 O(s*(t-s)) => O(s*t)")]),e._v(" "),a("p",[e._v("使用哈希使遍历操作复杂度恢复到线性的 O(s+t)")]),e._v(" "),a("ol",[a("li",[e._v("给定一个散列值 r ,每次操作添加一个新元素到末尾, 并弹出首位")]),e._v(" "),a("li",[e._v("r(): hash value of x = h(x)")])]),e._v(" "),a("p",[e._v("Karp-Rabin 字符串匹配算法 关键在于构造(Rolling Hash)滚动哈希表的数据结构")]),e._v(" "),a("ol",[a("li",[e._v("循环"),a("code",[e._v("S")]),e._v(", 计算目标子串的哈希值 设定第一个滚动哈希值")]),e._v(" "),a("li",[e._v("截取"),a("code",[e._v("T")]),e._v("前"),a("code",[e._v("s")]),e._v("个元素 设定第二个滚动哈希值")]),e._v(" "),a("li",[e._v("循环一遍")])])])}),[],!1,null,null,null);t.default=s.exports}}]);