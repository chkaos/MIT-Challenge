(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{480:function(e,n,o){"use strict";o.r(n);var t=o(45),s=Object(t.a)({},(function(){var e=this,n=e.$createElement,o=e._self._c||n;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"_22-peer-to-peer-trackerless-bittorrent-and-dhts"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_22-peer-to-peer-trackerless-bittorrent-and-dhts"}},[e._v("#")]),e._v(" 22.Peer-to-peer: Trackerless Bittorrent and DHTs")]),e._v(" "),o("p",[e._v("Lecture outline:\npeer-to-peer (P2P)\nBitTorrent\nDHTs\nChord")]),e._v(" "),o("p",[e._v("Peer-to-peer\n[user computers, files, direct xfers]\nusers computers talk directly to each other to implement service\nin contrast to user computers talking to central servers\ncould be closed or open\nexamples:\nskype, video and music players, file sharing")]),e._v(" "),o("p",[e._v("Why might P2P be a win?\nspreads network/caching costs over users\nabsence of server may mean:\neasier to deploy\nless chance of overload\nsingle failure won't wreck the whole system\nharder to attack")]),e._v(" "),o("p",[e._v("Why don't all Internet services use P2P?\ncan be hard to find data items over millions of users\nuser computers not as reliable than managed servers\nif open, can be attacked via evil participants")]),e._v(" "),o("p",[e._v("The result is that P2P has some successful niches:\nClient-client video/music, where serving costs are high\nChat (user to user anyway; privacy and control)\nPopular data but owning organization has no money\nNo natural single owner or controller (Bitcoin)\nIllegal file sharing")]),e._v(" "),o("p",[e._v("Example: classic BitTorrent\na cooperative download system, very popular!\nuser clicks on download link for e.g. latest Linux kernel distribution\ngets torrent file w/ content hash and IP address of tracker\nuser's BT client talks to tracker\ntracker tells it list of other user clients w/ downloaded file\nuser't BT client talks to one or more client's w/ the file\nuser's BT client tells tracker it has a copy now too\nuser's BT client serves the file to others for a while\nthe point:\nprovides huge download b/w w/o expensive server/link")]),e._v(" "),o("p",[e._v('BitTorrent can also use a DHT instead of / as well as a tracker\nthis is the topic of today\'s readings\nBT clients cooperatively implement a giant key/value store\n"distributed hash table"\nthe key is the file content hash ("infohash")\nthe value is the IP address of a client willing to serve the file\nKademlia can store multiple values for a key\nclient does get(infohash) to find other clients willing to serve\nand put(infohash, self) to register itself as willing to serve\nclient also joins the DHT to help implement it')]),e._v(" "),o("p",[e._v("Why might the DHT be a win for BitTorrent?\nsingle giant tracker, less fragmented than many trackers\nso clients more likely to find each other\nmaybe a classic tracker too exposed to legal &c attacks\nit's not clear that BitTorrent depends heavily on the DHT\nmostly a backup for classic trackers?")]),e._v(" "),o("p",[e._v("How do DHTs work?")]),e._v(" "),o("p",[e._v("Scalable DHT lookup:\nKey/value store spread over millions of nodes\nTypical DHT interface:\nput(key, value)\nget(key) -> value\nloose consistency; likely that get(k) sees put(k), but no guarantee\nloose guarantees about keeping data alive")]),e._v(" "),o("p",[e._v("Why is it hard?\nMillions of participating nodes\nCould broadcast/flood request -- but too many messages\nEvery node could know about every other node\nThen hashing is easy\nBut keeping a million-node table up to date is hard\nWe want modest state, and modest number of messages/lookup")]),e._v(" "),o("p",[e._v('Basic idea\nImpose a data structure (e.g. tree) over the nodes\nEach node has references to only a few other nodes\nLookups traverse the data structure -- "routing"\nI.e. hop from node to node\nDHT should route get() to same node as previous put()')]),e._v(" "),o("p",[e._v('Example: The "Chord" peer-to-peer lookup system\nBy Stoica, Morris, Karger, Kaashoek and Balakrishnan; 2001')]),e._v(" "),o("p",[e._v("Chord's ID-space topology\nRing: All IDs are 160-bit numbers, viewed in a ring.\nEach node has an ID, randomly chosen")]),e._v(" "),o("p",[e._v('Assignment of key IDs to node IDs?\nKey stored on first node whose ID is equal to or greater than key ID.\nCloseness is defined as the "clockwise distance"\nIf node and key IDs are uniform, we get reasonable load balance.\nSo keys IDs should be hashes (e.g. bittorrent infohash)')]),e._v(" "),o("p",[e._v('Basic routing -- correct but slow\nQuery is at some node.\nNode needs to forward the query to a node "closer" to key.\nIf we keep moving query closer, eventually we\'ll win.\nEach node knows its "successor" on the ring.\nn.lookup(k):\nif n < k <= n.successor\nreturn n.successor\nelse\nforward to n.successor\nI.e. forward query in a clockwise direction until done\nn.successor must be correct!\notherwise we may skip over the responsible node\nand get(k) won\'t see data inserted by put(k)')]),e._v(" "),o("p",[e._v("Forwarding through successor is slow\nData structure is a linked list: O(n)\nCan we make it more like a binary search?\nNeed to be able to halve the distance at each step.")]),e._v(" "),o("p",[e._v("log(n) \"finger table\" routing:\nKeep track of nodes exponentially further away:\nNew state: f[i] contains successor of n + 2^i\nn.lookup(k):\nif n < k <= n.successor:\nreturn successor\nelse:\nn' = closest_preceding_node(k) -- in f[]\nforward to n'")]),e._v(" "),o("p",[e._v("for a six-bit system, maybe node 8's looks like this:\n0: 14\n1: 14\n2: 14\n3: 21\n4: 32\n5: 42")]),e._v(" "),o("p",[e._v("Why do lookups now take log(n) hops?\nOne of the fingers must take you roughly half-way to target")]),e._v(" "),o("p",[e._v("There's a binary lookup tree rooted at every node\nThreaded through other nodes' finger tables\nThis is "),o("em",[e._v("better")]),e._v(" than simply arranging the nodes in a single tree\nEvery node acts as a root, so there's no root hotspot\nBut a lot more state in total")]),e._v(" "),o("p",[e._v("Is log(n) fast or slow?\nFor a million nodes it's 20 hops.\nIf each hop takes 50 ms, lookups take a second.\nIf each hop has 10% chance of failure, it's a couple of timeouts.\nSo in practice log(n) is better than O(n) but not great.")]),e._v(" "),o("p",[e._v("How does a new node acquire correct tables?\nGeneral approach:\nAssume system starts out w/ correct routing tables.\nUse routing tables to help the new node find information.\nAdd new node in a way that maintains correctness.\nNew node m:\nSends a lookup for its own key, to any existing node.\nThis yields m.successor\nm asks its successor for its entire finger table.\nAt this point the new node can forward queries correctly\nTweaks its own finger table in background\nBy looking up each m + 2^i")]),e._v(" "),o("p",[e._v("Does routing "),o("em",[e._v("to")]),e._v(' new node m now work?\nIf m doesn\'t do anything,\nlookup will go to where it would have gone before m joined.\nI.e. to m\'s predecessor.\nWhich will return its n.successor -- which is not m.\nSo, for correctness, m\'s predecessor needs to set successor to m.\nEach node keeps track of its current predecessor.\nWhen m joins, tells its successor that its predecessor has changed.\nPeriodically ask your successor who its predecessor is:\nIf that node is closer to you, switch to that guy.\nSo if we have x m y\nx.successor will be y (now incorrect)\ny.predecessor will be m\nx will ask its x.successor for predecessor\nx learns about m\nsets x.successor to m\ntells m "x is your predecessor"\ncalled "stabilization"\nCorrect successors are sufficient for correct lookups!')]),e._v(" "),o("p",[e._v("What about concurrent joins?\nTwo new nodes with very close ids, might have same successor.\nExample:\nInitially 40 then 70\n50 and 60 join concurrently\nat first 40, 50, and 60 think their successor is 70!\nwhich means lookups for e.g. 45 will yield 70, not 50\nafter one stabilization, 40 and 50 will learn about 60\nthen 40 will learn about 50")]),e._v(" "),o("p",[e._v("To maintain log(n) lookups as nodes join,\nEvery one periodically looks up each finger (each n + 2^i)")]),e._v(" "),o("p",[e._v("Chord's routing is conceptually similar to Kademlia's\nFinger table similar to bucket levels\nBoth halve the metric distance for each step\nBoth are about speed and can be imprecise\nn.successor similar to Kademlia's requirement that\neach node know of all the nodes that are very close in xor-space\nin both cases care is needed to ensure that different lookups\nfor same key converge on exactly the same node")]),e._v(" "),o("p",[e._v("What about node failures?\nAssume nodes fail w/o warning. Strictly harder than graceful departure.\nTwo issues:\nOther nodes' routing tables refer to dead node.\nDead node's predecessor has no successor.\nIf you try to route via dead node, detect timeout, treat as empty table entry.\nI.e. route to numerically closer entry instead.\nFor dead successor\nFailed node might have been just before key ID!\nSo we need to know what its n.successor was\nMaintain a "),o("em",[e._v("list")]),e._v(" of successors: r successors.\nLookup answer is first live successor >= key\nor forward to "),o("em",[e._v("any")]),e._v(" successor < key")]),e._v(" "),o("p",[e._v("Kademlia has a faster plan for this\nsend alpha (or k) lookup RPCs in parallel, to different nodes\nsend more lookups as previous ones return info about nodes closer to key\nsingle non-responsive node won't cause lookup to suffer a timeout")]),e._v(" "),o("p",[e._v('Dealing with unreachable nodes during routing is extremely important\n"Churn" is very high in open p2p networks\nPeople close their laptops, move WiFi APs, &c pretty often\nMeasurement of Bittorrent/Kademlia suggest lookups are not very fast')]),e._v(" "),o("p",[e._v("Geographical/network locality -- reducing lookup time\nLookup takes log(n) messages.\nBut they are to random nodes on the Internet!\nWill often be very far away.\nCan we route through nodes close to us on underlying network?\nThis boils down to whether we have choices:\nIf multiple correct next hops, we can try to choose closest.")]),e._v(" "),o("p",[e._v("Idea:\nto fill a finger table entry, collect multiple nodes near n+2^i on ring\nperhaps by asking successor to n+2^i for its r successors\nuse lowest-ping one as i'th finger table entry")]),e._v(" "),o("p",[e._v("What's the effect?\nIndividual hops are lower latency.\nBut less and less choice (lower node density) as you get close in ID space.\nSo last few hops likely to be very long.\nThough if you are reading, and any replica will do,\nyou still have choice even at the end.")]),e._v(" "),o("p",[e._v("What about security?\nSelf-authenticating data, e.g. key = SHA1(value)\nSo DHT node can't forge data\nOf course it's annoying to have immutable data...\nCan someone cause millions of made-up hosts to join?\nThey don't exist, so routing will break?\nDon't believe new node unless it responds to ping, w/ random token.\nCan a DHT node claim that data doesn't exist?\nYes, though perhaps you can check other replicas\nCan a host join w/ IDs chosen to sit under every replica?\nOr \"join\" many times, so it is most of the DHT nodes?\nMaybe you can require (and check) that node ID = SHA1(IP address)")]),e._v(" "),o("p",[e._v("Why not just keep complete routing tables?\nSo you can always route in one hop?\nDanger in large systems: timeouts or cost of keeping tables up to date.")]),e._v(" "),o("p",[e._v("How to manage data?\nHere is the most popular plan.\nDHT doesn't guarantee durable storage\nSo whoever inserted must re-insert periodically if they care\nMay want to automatically expire if data goes stale (bittorrent)\nDHT does replicate each key/value item\nOn the nodes with IDs closest to the key, where looks will find them\nReplication can help spread lookup load as well as tolerate faults\nWhen a node joins:\nsuccessor moves some keys to it\nWhen a node fails:\nsuccessor probably already has a replica\nbut r'th successor now needs a copy")]),e._v(" "),o("p",[e._v("Retrospective\nDHTs seem very promising for finding data in large p2p systems\nDecentralization seems good for load, fault tolerance\nBut: the security problems are difficult\nBut: churn is a serious problem, particularly if log(n) is big\nSo DHTs have not had the impact that many hoped for")])])}),[],!1,null,null,null);n.default=s.exports}}]);