(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{405:function(t,r,s){"use strict";s.r(r);var e=s(45),a=Object(e.a)({},(function(){var t=this,r=t.$createElement,s=t._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_3-insertion-sort-merge-sort"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-insertion-sort-merge-sort"}},[t._v("#")]),t._v(" 3 Insertion Sort, Merge Sort")]),t._v(" "),s("h2",{attrs:{id:"why-sorting"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#why-sorting"}},[t._v("#")]),t._v(" why sorting?")]),t._v(" "),s("ul",[s("li",[t._v("音乐库，通讯录有排序需求")]),t._v(" "),s("li",[t._v("查找中位数，近似数, 查重，二分查找, 识别统计异常值等操作排过序的输入会快很多")]),t._v(" "),s("li",[t._v("文件压缩，渲染图层排列")])]),t._v(" "),s("h2",{attrs:{id:"insertion-sort"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#insertion-sort"}},[t._v("#")]),t._v(" insertion sort")]),t._v(" "),s("p",[t._v("当比较的成本比 swap 大得多时, 比较步骤可用二分法替换, 整个插入排序的复杂度虽然维持不变O(N^2), 由于比较步骤复杂度为 O(NlogN), 性能会提高不少")]),t._v(" "),s("h2",{attrs:{id:"merge-sort"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#merge-sort"}},[t._v("#")]),t._v(" merge sort")]),t._v(" "),s("p",[t._v("标准递归算法, 在合并过程中, 将合并两个已排过序的数组变成双指针问题。\n二分法构成的树有 lgN + 1 层, n 个枝叶")])])}),[],!1,null,null,null);r.default=a.exports}}]);