(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{382:function(t,a,r){"use strict";r.r(a);var e=r(42),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"_10-open-addressing-cryptographic-hashing"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-open-addressing-cryptographic-hashing"}},[t._v("#")]),t._v(" 10 Open Addressing, Cryptographic Hashing")]),t._v(" "),r("h3",{attrs:{id:"open-addressing"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#open-addressing"}},[t._v("#")]),t._v(" Open Addressing")]),t._v(" "),r("h4",{attrs:{id:"插入"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#插入"}},[t._v("#")]),t._v(" 插入")]),t._v(" "),r("p",[t._v("探测 probing: 给定一个key, 尝试看看能否找到插槽进行插入操作\n试算数(0, m-1)")]),t._v(" "),r("p",[t._v("hash 方法接收2个参数, 密钥和试算数\n每次插入的时候一直寻找新的插槽, 没找到的话增加试算数, keep probing till the end.")]),t._v(" "),r("h4",{attrs:{id:"删除"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#删除"}},[t._v("#")]),t._v(" 删除")]),t._v(" "),r("p",[t._v('replace deleted item with "DeleteMe" Flag (区别于 nil)\n插入操作对应改变, 插入的时候视 "DeleteMe" 和 nil相同, 查找的时候则跳过对项目经理应插槽')]),t._v(" "),r("h4",{attrs:{id:"probing-strategy"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#probing-strategy"}},[t._v("#")]),t._v(" Probing Strategy")]),t._v(" "),r("p",[t._v("cluster 开始获得的连续占用插槽组")]),t._v(" "),r("ul",[r("li",[t._v("Linear Probing")]),t._v(" "),r("li",[t._v("Double hashing")])]),t._v(" "),r("h3",{attrs:{id:"cryptographic-hashing"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cryptographic-hashing"}},[t._v("#")]),t._v(" Cryptographic Hashing")]),t._v(" "),r("p",[t._v("例子: 密码存储, 文件修改检测, 电子签名")])])}),[],!1,null,null,null);a.default=s.exports}}]);