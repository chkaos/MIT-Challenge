(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{366:function(t,a,e){t.exports=e.p+"assets/img/layerModel.1e75543d.jpg"},367:function(t,a,e){t.exports=e.p+"assets/img/IPv4_Datagram.3d6d6005.jpg"},368:function(t,a,e){t.exports=e.p+"assets/img/arp.17c0390e.jpg"},448:function(t,a,e){"use strict";e.r(a);var r=e(45),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"_1-the-internet-and-ip"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-the-internet-and-ip"}},[t._v("#")]),t._v(" 1. The Internet and IP")]),t._v(" "),r("h3",{attrs:{id:"connectivity"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#connectivity"}},[t._v("#")]),t._v(" connectivity")]),t._v(" "),r("p",[t._v("Internet的连接能力是指两台计算机互相连接并可以传输数据, 抽象来看就是两个应用之间的管道")]),t._v(" "),r("h3",{attrs:{id:"world-wide-web-http"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#world-wide-web-http"}},[t._v("#")]),t._v(" World Wide Web(HTTP)")]),t._v(" "),r("p",[t._v("HTTP是一个客户端（用户）和服务端（网站）之间请求和应答的标准，通常使用TCP协议。")]),t._v(" "),r("ul",[r("li",[t._v("document-centric: 以文件为主")])]),t._v(" "),r("h2",{attrs:{id:"应用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[t._v("#")]),t._v(" 应用")]),t._v(" "),r("h3",{attrs:{id:"network-applications"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#network-applications"}},[t._v("#")]),t._v(" Network Applications")]),t._v(" "),r("ul",[r("li",[t._v("两台本地电脑通过网络读写数据")]),t._v(" "),r("li",[t._v("dominant model: 双向可靠字节流连接\n"),r("ul",[r("li",[t._v("一方读另一方写")]),t._v(" "),r("li",[t._v("操作是双向的")]),t._v(" "),r("li",[t._v("可靠(除非网络断开)")])])])]),t._v(" "),r("h3",{attrs:{id:"bittorrent"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#bittorrent"}},[t._v("#")]),t._v(" BitTorrent")]),t._v(" "),r("p",[t._v("允许人们分享交换大文件, 不像 web里client从服务器请求文件, BitTorrent是客户从其他客户那里请求文件;\n如果只有少部分客户端拥有某一切片, 那么这将成为下载的瓶颈, 所以有了Rare first policy")]),t._v(" "),r("p",[t._v("文件以切块形式存在")]),t._v(" "),r("p",[t._v("swarm(虫群?) - 分享同个种子的一群客户端")]),t._v(" "),r("p",[t._v("下载的时候需要一个 Torrent file, 描述了想要下载的文件信息")]),t._v(" "),r("p",[t._v("tracker: 持续记录 clients of the swarm")]),t._v(" "),r("h3",{attrs:{id:"skype"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#skype"}},[t._v("#")]),t._v(" skype")]),t._v(" "),r("p",[t._v("两台电脑互相请求数据\nNAT（Network Address Translation，网络地址转换）: 在计算机网络中是一种在IP数据包通过路由器或防火墙时重写来源IP地址或目的IP地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有IP地址访问互联网的私有网络中。它是一个方便且得到了广泛应用的技术。当然，NAT也让主机之间的通信变得复杂，导致了通信效率的降低。个人电脑常用;")]),t._v(" "),r("p",[t._v("一个Client behind NAT: 使用 Rendezvous server 跳过 NAT的限制, 另一个Client则直接发送数据至 Rendezvous server;\nboth clients behind NAT: Relay Server")]),t._v(" "),r("h2",{attrs:{id:"_4层模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4层模型"}},[t._v("#")]),t._v(" 4层模型")]),t._v(" "),r("p",[t._v("这里主要介绍 TCP/IP 4层模型")]),t._v(" "),r("p",[r("img",{attrs:{src:e(366),alt:"TCP/IP4层模型"}})]),t._v(" "),r("ul",[r("li",[t._v("7层协议是指OSI七层协议模型，主要是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）")])]),t._v(" "),r("p",[t._v("Each layer provide a services to the layer above.")]),t._v(" "),r("h3",{attrs:{id:"link-layer-etherent-wifi-dsl-4g"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#link-layer-etherent-wifi-dsl-4g"}},[t._v("#")]),t._v(" Link Layer: (Etherent, Wifi, DSL, 4G)")]),t._v(" "),r("p",[t._v("数据包（英语：Data packet），又称分组，是在分组交换网络中传输的格式化数据单位。")]),t._v(" "),r("p",[t._v("一个数据包（packet）分成两个部分，包括控制信息，也就是表头资料（header），和资料本身，也就是负载（payload）。header 一般包含寄件人和收件人的信息;")]),t._v(" "),r("p",[t._v("我们可以将一个数据包比作为一封信，表头资料相当于信封，而数据包的数据部分则相当于信的内容。和信不同的是，有时候一个大数据包可以分成多个小数据包。")]),t._v(" "),r("h3",{attrs:{id:"network-internet-protocol-ip"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#network-internet-protocol-ip"}},[t._v("#")]),t._v(" Network: Internet Protocol(IP)")]),t._v(" "),r("ul",[r("li",[t._v("IP 传递数据报(无保证)")]),t._v(" "),r("li",[t._v("数据报存在无序和丢失的问题")]),t._v(" "),r("li",[t._v("提供 unreliable datagram delivery service")])]),t._v(" "),r("h3",{attrs:{id:"transport-最常见的传输协议为-tcp-transmission-control-protocol-用于解决网络层传输数据包无序和丢失的问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#transport-最常见的传输协议为-tcp-transmission-control-protocol-用于解决网络层传输数据包无序和丢失的问题"}},[t._v("#")]),t._v(" Transport: 最常见的传输协议为 TCP (Transmission control protocol), 用于解决网络层传输数据包无序和丢失的问题;")]),t._v(" "),r("ul",[r("li",[t._v("为应用层提供保证数据报顺序及重新发送的服务")])]),t._v(" "),r("p",[t._v('不是所有应用都需要"数据顺序保证"')]),t._v(" "),r("ul",[r("li",[t._v("UDP(用户数据报协议, User datagram protocol)")])]),t._v(" "),r("blockquote",[r("p",[t._v("UDP只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以UDP有时候也被认为是不可靠的数据报协议）。UDP在IP数据报的头部仅仅加入了复用和数据校验字段。")])]),t._v(" "),r("p",[t._v("UDP适用于不需要或在程序中执行错误检查和纠正的应用，它避免了协议栈中此类处理的开销。对时间有较高要求的应用程序通常使用UDP，因为丢弃数据包比等待或重传导致延迟更可取。")]),t._v(" "),r("p",[t._v("-RTP(Real time protocol) 等其他")]),t._v(" "),r("h3",{attrs:{id:"application-layer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#application-layer"}},[t._v("#")]),t._v(" Application layer")]),t._v(" "),r("p",[t._v("http, smtp, ssh, ftp ...")]),t._v(" "),r("h2",{attrs:{id:"ip服务模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ip服务模型"}},[t._v("#")]),t._v(" IP服务模型")]),t._v(" "),r("p",[t._v('IP 在互联网中属于"瓶颈", 不可避免的一环. IP服务模型一个很好的比喻是邮局服务')]),t._v(" "),r("ul",[r("li",[r("p",[t._v("Datagram")])]),t._v(" "),r("li",[r("p",[t._v("Unreliable")])]),t._v(" "),r("li",[r("p",[t._v("Best effort")])]),t._v(" "),r("li",[r("p",[t._v("Connectionless: 无连接式通信，又译为免接式通信，一种通信传输模式，使用于电信及电脑网络中。在两个端点之间传递的消息，不需要事先安排，创建连线。")])]),t._v(" "),r("li",[r("p",[t._v("Simple, dumb, minimal: Faster, more streamlined and lower cost to build and maintain;")])]),t._v(" "),r("li",[r("p",[t._v("The end-to-end principle: Where possible, implement features in the end hosts.")])]),t._v(" "),r("li",[r("p",[t._v("Allows a variety of reliable(or unreliable) services to be build on top.")])]),t._v(" "),r("li",[r("p",[t._v("Works over any link layer: IP makes very few assumptions about the link layer below.")])])]),t._v(" "),r("h3",{attrs:{id:"细节"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#细节"}},[t._v("#")]),t._v(" 细节")]),t._v(" "),r("ol",[r("li",[t._v("避免数据包无限循环(在数据报头加入 hop-count 字段来解决数据包在传输过程中由于某些原因在路由间无限循环 /Time to live, TTL field), 通常该数字是128, 其本身不解决无限循环的问题, 只是限制了上限次数")]),t._v(" "),r("li",[t._v("数据包过长时会被切片")]),t._v(" "),r("li",[t._v("header checksum(校验)减少数据报被发送到错误地址的概率")]),t._v(" "),r("li",[t._v("允许新版本IP("),r("a",{attrs:{href:"#IPV4"}},[t._v("IPv4")]),t._v(", 32位/ (IPv6, 128位)")]),t._v(" "),r("li",[t._v("允许报头加入自定义字段")])]),t._v(" "),r("p",[r("img",{attrs:{src:e(367),alt:"IPV4数据报结构"}})]),t._v(" "),r("h2",{attrs:{id:"packet的生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#packet的生命周期"}},[t._v("#")]),t._v(" packet的生命周期")]),t._v(" "),r("p",[t._v("以客户端发送请求到服务器为例")]),t._v(" "),r("h3",{attrs:{id:"工具-wireshark-traceroute"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#工具-wireshark-traceroute"}},[t._v("#")]),t._v(" 工具 wireshark, traceroute")]),t._v(" "),r("h2",{attrs:{id:"原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原则"}},[t._v("#")]),t._v(" 原则:")]),t._v(" "),r("h3",{attrs:{id:"packet-switching"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#packet-switching"}},[t._v("#")]),t._v(" Packet Switching")]),t._v(" "),r("p",[t._v("定义:\nPacket: 一个以到达目的地为目标并携带所有必要信息的数据独立单位.\nPacket Switching: 分别为各packet选择离开的link, 如果link是空闲的则发送, 否则保存数据包直到可发送状态;")]),t._v(" "),r("h4",{attrs:{id:"simple-packet-forwarding"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#simple-packet-forwarding"}},[t._v("#")]),t._v(" Simple packet forwarding")]),t._v(" "),r("h4",{attrs:{id:"efficient-sharing-of-links"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#efficient-sharing-of-links"}},[t._v("#")]),t._v(" Efficient sharing of links")]),t._v(" "),r("p",[t._v("流 flow: 一系列数据报属于同个端对端交流, eg TCP连接, No per-flow state required")]),t._v(" "),r("p",[t._v("突发: 是事件活动或事件频率的间歇性增加和减少;")]),t._v(" "),r("p",[t._v("Data traffic is bursty -> Statistical Multiplexing\n统计复用是一种类型的通信链路共享非常相似的动态带宽分配。")]),t._v(" "),r("ul",[r("li",[t._v("Packet Switching 允许流使用所有可用的链路容量")]),t._v(" "),r("li",[t._v("Packet Switching 允许流使用分享链路容量")])]),t._v(" "),r("h3",{attrs:{id:"layer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#layer"}},[t._v("#")]),t._v(" layer")]),t._v(" "),r("p",[t._v("层属于功能组件, 是层级式依序与上下层沟通;\n接收下层提供的数据, 向上层提供特定的服务")]),t._v(" "),r("h4",{attrs:{id:"layering-in-computer-system"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#layering-in-computer-system"}},[t._v("#")]),t._v(" layering in computer system")]),t._v(" "),r("ol",[r("li",[t._v("编辑")])]),t._v(" "),r("blockquote",[r("p",[t._v("源码")])]),t._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[t._v("编译(语法分析 -> 解析 -> 预处理 -> 代码生成及优化)")])]),t._v(" "),r("blockquote",[r("p",[t._v("目标代码")])]),t._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[t._v("链接 (link 编译对象文件和库)")])]),t._v(" "),r("blockquote",[r("p",[t._v("可执行")])]),t._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[t._v("执行(CPU运行可执行文件)")])]),t._v(" "),r("p",[t._v("汇编语言 (Assembly language): 是任何一种用于电子计算机、微处理器、微控制器，或其他可编程器件的低级语言。在不同的设备中，汇编语言对应着不同的机器语言指令集。一种汇编语言专用于某种计算机系统结构，而不像许多高级语言，可以在不同系统平台之间移植。 使用汇编语言编写的源代码，然后通过相应的汇编程序将它们转换成可执行的机器代码。")]),t._v(" "),r("p",[t._v("模块化, 复用性\n分层结构将应用系统正交地划分为若干层，每一层只解决问题的一部分，通过各层的协作提供整体解决方案。\n分层结构具有良好的可扩展性，为应用系统的演化增长提供了一个灵活的框架，具有良好的可扩展性。\n分层架构易于维护。")]),t._v(" "),r("h3",{attrs:{id:"encapsulation-封装"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#encapsulation-封装"}},[t._v("#")]),t._v(" encapsulation 封装")]),t._v(" "),r("p",[t._v("封装是我们灵活组装协议层成数据包的过程, 把下级的数据包放在当前层的数据包的"),r("code",[t._v("data")]),t._v("部分;")]),t._v(" "),r("h4",{attrs:{id:"面试题-浏览器输入url时发生了什么-todo"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#面试题-浏览器输入url时发生了什么-todo"}},[t._v("#")]),t._v(" 面试题: 浏览器输入URL时发生了什么(todo)")]),t._v(" "),r("p",[t._v("VPN(Virtual Private Network): 是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。它利用隧道协议（Tunneling Protocol）来达到发送端认证、消息保密与准确性等功能。")]),t._v(" "),r("h2",{attrs:{id:"memory-byte-order-and-packet-formats"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#memory-byte-order-and-packet-formats"}},[t._v("#")]),t._v(" Memory, Byte Order and Packet Formats")]),t._v(" "),r("p",[t._v("计算机内存例子:")]),t._v(" "),r("h3",{attrs:{id:"byte-order"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#byte-order"}},[t._v("#")]),t._v(" Byte Order")]),t._v(" "),r("p",[t._v("Endianness 字节顺序，又称端序或尾序，在计算机科学领域中，指电脑内存中或在数字通信链路中，组成多字节的字的字节的排列顺序。 在几乎所有的机器上，多字节对象都被存储为连续的字节序列。")]),t._v(" "),r("p",[t._v("字节的排列方式有两个通用规则。例如，将一个多位数的低位放在较小的地址处，高位放在较大的地址处，则称小端序(LSB, least significant byte)；反之则称大端序(MSB, most significant byte)。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。")]),t._v(" "),r("h3",{attrs:{id:"network-byte-order"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#network-byte-order"}},[t._v("#")]),t._v(" Network Byte Order")]),t._v(" "),r("p",[t._v("不同处理器可能采用不同字节顺序;\n两个不同字节顺序的相同值比较不相等;\nNetwork Byte Order是大端序")]),t._v(" "),r("blockquote",[r("p",[t._v("Be careful whenever you handle network data !!!")])]),t._v(" "),r("h3",{attrs:{id:"packet-formats"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#packet-formats"}},[t._v("#")]),t._v(" Packet Formats")]),t._v(" "),r("h2",{attrs:{id:"ipv4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ipv4"}},[t._v("#")]),t._v(" IPV4")]),t._v(" "),r("p",[t._v("Names and Addresses:IPV4\n用于标记网络内计算机的身份, 网际协议版本4（英语：Internet Protocol version 4，缩写：IPv4，又称互联网通信协议第四版）是网际协议开发过程中的第四个修订版本，也是此协议第一个被广泛部署和使用的版本。其后继版本为IPv6，直到2011年，IANA IPv4位址完全用尽时，IPv6仍处在部署的初期。")]),t._v(" "),r("h3",{attrs:{id:"netmask"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#netmask"}},[t._v("#")]),t._v(" NetMask")]),t._v(" "),r("p",[t._v("A netmask is a 32-bit binary mask used to divide an IP address into subnets and specify the network's available hosts.")]),t._v(" "),r("p",[t._v("A commonly used netmask is a 24-bit netmask, as seen below.")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("Netmask")]),t._v(" "),r("th",[t._v("255.")]),t._v(" "),r("th",[t._v("255.")]),t._v(" "),r("th",[t._v("255.")]),t._v(" "),r("th",[t._v("0")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("Binary")]),t._v(" "),r("td",[t._v("11111111")]),t._v(" "),r("td",[t._v("11111111")]),t._v(" "),r("td",[t._v("11111111")]),t._v(" "),r("td",[t._v("00000000")])]),t._v(" "),r("tr",[r("td",[t._v("Netmask length")]),t._v(" "),r("td",[t._v("8")]),t._v(" "),r("td",[t._v("16")]),t._v(" "),r("td",[t._v("24")]),t._v(" "),r("td",[t._v("--")])])])]),t._v(" "),r("p",[t._v("以Netmask 255.255.255.0 为例\n"),r("code",[t._v("10.20.20.45")]),t._v(" 和 "),r("code",[t._v("10.20.20.46")]),t._v(" 处于同个网络内, 与 "),r("code",[t._v("10.20.21.46")]),t._v(" 则不处于同个网络内.")]),t._v(" "),r("h3",{attrs:{id:"address-structure-network-host"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#address-structure-network-host"}},[t._v("#")]),t._v(" Address structure (network+host)")]),t._v(" "),r("h3",{attrs:{id:"地址耗尽"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#地址耗尽"}},[t._v("#")]),t._v(" 地址耗尽")]),t._v(" "),r("p",[t._v("从20世纪80年代起，一个很明显的问题是IPv4地址在以比设计时的预计更快的速度耗尽。[4] 这是创建分类网络、无类别域间路由，和最终决定重新设计基于更长地址的互联网协议（IPv6）的诱因。")]),t._v(" "),r("p",[t._v("一些市场力量也加快了IPv4地址的耗尽，如：")]),t._v(" "),r("ul",[r("li",[t._v("互联网用户的急速增长；")]),t._v(" "),r("li",[t._v("总是开着的设备：ADSL调制解调器、缆线调制解调器等；")]),t._v(" "),r("li",[t._v("移动设备：笔记本电脑、PDA、移动电话等。")])]),t._v(" "),r("p",[t._v("随着互联网的增长，各种各样的技术随之产生以应对IPv4地址的耗尽，如：")]),t._v(" "),r("ul",[r("li",[t._v("网络地址转换（NAT）；")]),t._v(" "),r("li",[t._v("专用网络的使用；")]),t._v(" "),r("li",[t._v("动态主机设置协议（DHCP）；")]),t._v(" "),r("li",[t._v("基于名字的虚拟主机；")]),t._v(" "),r("li",[t._v("区域互联网注册管理机构对地址分配的控制；")]),t._v(" "),r("li",[t._v("对互联网初期分配的大地址块的回收。")])]),t._v(" "),r("h3",{attrs:{id:"longest-prefix-match-routing-tables"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#longest-prefix-match-routing-tables"}},[t._v("#")]),t._v(" Longest prefix match (Routing Tables)")]),t._v(" "),r("p",[t._v("最长前缀匹配用于传输数据包的路由选择")]),t._v(" "),r("p",[t._v("每个路由器都有一个 forwarding table(入口/链接) 用于匹配目标地址")]),t._v(" "),r("h3",{attrs:{id:"address-resolution-protocol-地址解析协议"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#address-resolution-protocol-地址解析协议"}},[t._v("#")]),t._v(" Address Resolution Protocol(地址解析协议)")]),t._v(" "),r("p",[t._v("在以太网协议中规定，同一局域网中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的MAC地址。而在TCP/IP协议中，网络层和传输层只关心目标主机的IP地址。这就导致在以太网中使用IP协议时，数据链路层的以太网协议接到上层IP协议提供的数据中，只包含目的主机的IP地址。于是需要一种方法，根据目的主机的IP地址，获得其MAC地址。这就是ARP协议要做的事情。所谓地址解析（address resolution）就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。")]),t._v(" "),r("p",[r("img",{attrs:{src:e(368),alt:""}})])])}),[],!1,null,null,null);a.default=s.exports}}]);