(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{419:function(a,t,r){"use strict";r.r(t);var s=r(45),e=Object(s.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"_18-speeding-up-dijkstra"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_18-speeding-up-dijkstra"}},[a._v("#")]),a._v(" 18. Speeding up Dijkstra")]),a._v(" "),r("h3",{attrs:{id:"bidirectional-search"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#bidirectional-search"}},[a._v("#")]),a._v(" bidirectional search")]),a._v(" "),r("p",[a._v("双向搜索算法是一种图的遍历算法，用于在有向图中搜索从一个顶点到另一个顶点的最短路径。算法同时运行两个搜索：一个从初始状态正向搜索，另一个从目标状态反向搜索，当两者边界在中间汇合时搜索停止。")]),a._v(" "),r("ol",[r("li",[a._v("forward search from source")]),a._v(" "),r("li",[a._v("backward search from target")])]),a._v(" "),r("p",[a._v("一棵分支因子b的树, 初始节点到目标节点的距离为d，该算法的正向和反向搜索复杂度都是O(b^d/2) ，两者相加后远远小于普通的单项搜索算法（复杂度为O(b^d)）。")]),a._v(" "),r("h3",{attrs:{id:"a-搜索算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#a-搜索算法"}},[a._v("#")]),a._v(" A*搜索算法")]),a._v(" "),r("p",[a._v("A*搜索算法是一种在图形平面上，有多个节点的路径，求出最低通过成本的算法。常用于游戏中的NPC的移动计算，或网络游戏的BOT的移动计算上。 该算法综合了最良优先搜索和Dijkstra算法的优点：在进行启发式搜索提高算法效率的同时，可以保证找到一条最优路径。")]),a._v(" "),r("p",[a._v("和 Dijkstra算法 比较, 时间复杂度没有改变, 只是提高了提早结束搜寻的可能性。")]),a._v(" "),r("p",[a._v("~"),r("a",{attrs:{href:"~@assets/50/a_star.png"}})])])}),[],!1,null,null,null);t.default=e.exports}}]);