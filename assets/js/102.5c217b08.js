(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{479:function(e,n,t){"use strict";t.r(n);var a=t(45),o=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_21-atomicity-optimistic-concurrency-control"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_21-atomicity-optimistic-concurrency-control"}},[e._v("#")]),e._v(" 21.Atomicity: Optimistic Concurrency Control")]),e._v(" "),t("p",[e._v("Paper: Efficient Optimistic Concurrency Control using Loosely\nSynchronized Clocks, by Adya, Gruber, Liskov and Maheshwari.")]),e._v(" "),t("p",[e._v("Why this paper?\nto look at optimistic concurrency control (OCC)\nOCC might help us get large scale, high speed, "),t("em",[e._v("and")]),e._v(" good semantics")]),e._v(" "),t("p",[e._v("Thor overview\n[clients, client caches, servers A-M N-Z]\ndata sharded over servers\ncode runs in clients (not like Argus; not an RPC system)\nclients read/write DB records from servers\nclients cache data locally for fast access\non client cache miss, fetch from server")]),e._v(" "),t("p",[e._v("Thor arrangement is fairly close to modern big web site habits\nclients, local fast cache, slower DB servers\nlike Facebook/memcache paper\nbut Thor has much better semantics")]),e._v(" "),t("p",[e._v("Thor programs use fully general transactions\nmulti-operation\nserializable\nso can do bank xfers w/o losing money, &c")]),e._v(" "),t("p",[e._v("Client caching makes transactions tricky\nwrites have to invalidatate cached copies\nhow to cope with reads of stale cached data?\nhow to cope with read-modify-write races?\nclients could lock before using each record\nbut that's slow -- probably need to contact server\nwrecks the whole point of fast local caching in clients\n(though caching read locks might be OK, as in paper Eval)")]),e._v(" "),t("p",[e._v('Thor uses optimistic concurrency control (OCC)\nan idea from the early 1980s\njust read and write the local copy\ndon\'t worry about other transactions until commit\nwhen transaction wants to commit:\nsend read/write info to server for "validation"\nvalidation decides if OK to commit -- if serializable\nif yes, send invalidates to clients with cached copies of written records\nif no, abort, discard writes\noptimistic b/c hopes for no conflict\nif turns out to be true, fast!\nif false, validation can detect, but slow')]),e._v(" "),t("p",[e._v("What should validation do?\nit looks at what the executing transactions read and wrote\ndecides if there's a serial execution order that would have gotten\nthe same results as the actual concurrent execution\nthere are many OCC validation algorithms!\ni will outline a few, leading up to Thor's")]),e._v(" "),t("p",[e._v('Validation scheme #1\na single validation server\nclients tell validation server the read and write VALUES\nseen by each transaction that wants to commit\n"read set" and "write set"\nvalidation must decide:\nwould the results be serializable if we let these\ntransactions commit?\nscheme #1 shuffles the transactions, looking for a serial order\nin which each read sees the value written by the most\nrecent write; if one exists, the execution was serializable.')]),e._v(" "),t("p",[e._v("Validation example 1:\ninitially, x=0 y=0 z=0\nT1: Rx0 Wx1\nT2: Rz0 Wz9\nT3: Ry1 Rx1\nT4: Rx0 Wy1\nvalidation needs to decide if this execution (reads, writes)\nis equivalent to some serial order\nyes: one such order is T4, T1, T3, T2; says yes to all\n(really T2 can go anywhere)\nnote this scheme is far more permissive than Thor's\ne.g. it allows transactions to see uncommitted writes")]),e._v(" "),t("p",[e._v("OCC is neat b/c transactions didn't need to lock!\nso they can run quickly from client caches\njust one msg exchange w/ validator per transaction\nnot one locking exchange per record used\nOCC excellent for T2 which didn't conflict with anything\nwe got lucky for T1 T3 T4, which do conflict")]),e._v(" "),t("p",[e._v("Validation example 2 -- sometimes must abort:\ninitially, x=0 y=0\nT1: Rx0 Wx1\nT2: Rx0 Wy1\nT3: Ry0 Rx1\nvalues not consistent w/ any serial order!\nT1 -> T3 (via x)\nT3 -> T2 (via y)\nT2 -> T1 (via x)\nthere's a cycle, so not the same as any serial execution\nperhaps T3 read a stale y=0 from cache\nor T2 read a style x=0 from cache\nin this case validation can abort one of them\nthen others are OK to commit\ne.g. abort T2\nthen T1, T3 is OK (but not T3, T1)")]),e._v(" "),t("p",[e._v("How should client handle abort?\nroll back the program (including writes to program variables)\nre-run from start of transaction\nhopefully won't be conflicts the second time\nOCC is best when conflicts are uncommon!")]),e._v(" "),t("p",[e._v("Do we need to validate read-only transactions?\nexample:\ninitially x=0 y=0\nT1: Wx1\nT2: Rx1 Wy2\nT3: Ry2 Rx0\ni.e. T3 read a stale x=0 from its cache, hadn't yet seen invalidate.\nneed to validate in order to abort T3.\nother OCC schemes can avoid validating read-only transactions\nkeep multiple versions -- but Thor and my schemes don't")]),e._v(" "),t("p",[e._v("Is OCC better than locking?\nyes, if few conflicts\navoids lock msgs, clients don't have to wait for locks\nno, if many conflicts\nOCC aborts, must re-start, perhaps many times\nlocking waits\nexample: simultaneous increment\nlocking:\nT1: Rx0 Wx1\nT2: -------Rx1  Wx2\nOCC:\nT1: Rx0 Wx1\nT2: Rx0 Wx1\nfast but wrong; must abort one")]),e._v(" "),t("p",[e._v("We really want "),t("em",[e._v("distributed")]),e._v(' OCC validation\nsplit storage and validation load over servers\neach storage server sees only xactions that use its data\neach storage server validates just its part of the xaction\ntwo-phase commit (2PC) to check that they all say "yes"\nonly really commit if all relevant servers say "yes"')]),e._v(" "),t("p",[e._v('Can we just distribute validation scheme #1?\nimagine server S1 knows about x, server S2 knows about y\nexample 2 again\nT1: Rx0 Wx1\nT2: Rx0 Wy1\nT3: Ry0 Rx1\nS1 validates just x information:\nT1: Rx0 Wx1\nT2: Rx0\nT3: Rx1\nanswer is "yes" (T2 T1 T3)\nS2 validates just y information:\nT2: Wy1\nT3: Ry0\nanswer is "yes" (T3 T2)\nbut we know the real answer is "no"')]),e._v(" "),t("p",[e._v("So simple distributed validation does not work\nthe validators must choose consistent orders!")]),e._v(" "),t("p",[e._v('Validation scheme #2\nIdea: client (or TC) chooses timestamp for committing xaction\nfrom loosely synchronized clocks, as in Thor\nvalidation checks that reads and writes are consistent with TS order\nsolves distrib validation problem:\ntimestamps tell the validators the order to check\nso "yes" votes will refer to the same order')]),e._v(" "),t("p",[e._v("Example 2 again, with timestamps:\nT1@100: Rx0 Wx1\nT2@110: Rx0 Wy1\nT3@105: Ry0 Rx1\nS1 validates just x information:\nT1@100: Rx0 Wx1\nT2@110: Rx0\nT3@105: Rx1\ntimestamps say order must be T1, T3, T2\ndoes not validate! T2 should have seen x=1\nS2 validates just y information:\nT2@110: Wy1\nT3@105: Ry0\ntimstamps say order must be T3, T2\nvalidates!\nS1 says no, S2 says yes, two-phase commit coordinator will abort")]),e._v(" "),t("p",[e._v("What have we given up by requiring timestamp order?\nexample:\nT1@100: Rx0 Wx1\nT2@50: Rx1 Wx2\nT2 follows T1 in real time, and sees T1's write\nbut T2 will abort, since TS says T2 comes first, so T1 should have seen x=2\ncould have committed, since T1 then T2 works\nthis will happen if client clocks are too far off\nif T1's client clock is ahead, or T2's behind\nso: requiring TS order can abort unnecessarily\nb/c validation no longer "),t("em",[e._v("searching")]),e._v(" for an order that works\ninstead merely "),t("em",[e._v("checking")]),e._v(" that TS order consistent w/ reads, writes\nwe've given up some optimism by requiring TS order\nmaybe not a problem if clocks closely synched\nmaybe not a problem if conflicts are rare")]),e._v(" "),t("p",[e._v("Problem with schemes so far:\ncommit messages contained "),t("em",[e._v("values")]),e._v(", which can be big\ncould instead use version numbers to check whether\nlater xaction read earlier xaction's write\nlet's use writing xaction's TS as record version number")]),e._v(" "),t("p",[e._v("Validation scheme #4\ntag each DB record (and cached record) with TS of xation that last wrote it\nvalidation requests carry TS of each record read")]),e._v(" "),t("p",[e._v("Our example for scheme #4:\nall values start with timestamp 0\nT1@100: Rx@0 Wx\nT2@110: Rx@0 Wy\nT3@105: Ry@0 Rx@100\nnote:\nreads have timestamp that was in read record, not value\nwrites don't include either value or timestamp\nS1 validates just x information:\norders the transactions by timestamp:\nT1@100: Rx@0 Wx\nT3@105: Rx@100\nT2@110: Rx@0\nthe question: does each read see the most recent write?\nT3 is ok, but T2 is not\nS2 validates just y information:\nagain, sort by TS, check each read saw latest write:\nT3@105: Ry@0\nT2@110: Wy\nthis does validate\nso scheme #4 abort, correctly, reasoning only about version TSs")]),e._v(" "),t("p",[e._v("what have we give up by thinking about version #s rather than values?\nmaybe version numbers are different but values are the same\ne.g.\nT1@100: Wx1\nT2@110: Wx2\nT3@120: Wx1\nT4@130: Rx1@100\ntimestamps say we should abort T4 b/c read a stale version\nshould have read T3's write\nso scheme #4 will abort\nbut T4 read the correct value -- x=1\nso abort wasn't necessary")]),e._v(" "),t("p",[e._v("Problem: per-record timestamp might use too much storage space\nThor wants to avoid space overhead\nmaybe important, maybe not")]),e._v(" "),t("p",[e._v("Validation scheme #5\nThor's invalidation scheme: no timestamps on records\nhow can validation detect that a transaction read stale data?\nit read stale data b/c earlier xaction's invalidation hadn't yet arrived!\nso server can track invalidation msgs that might not have arrived yet\n\"invalid set\" -- one per client\ndelete invalid set entry when client ACKs invalidation msg\nserver aborts committing xaction if it read record in client's invalid set\nclient aborts running xaction if it read record mentioned in invalidation")]),e._v(" "),t("p",[e._v("Example use of invalid set\n[timeline]\nClient C1:\nT2@105 ... Rx ... 2PC commit point\nimagine that client acts as 2PC coordinator\nServer:\nVQ: T1@100 Wx\nT1 committed, x in C1's invalid set\nserver has sent invalidation message to C1")]),e._v(" "),t("p",[e._v("Three cases:")]),e._v(" "),t("ol",[t("li",[e._v("invalidation arrives before T2 reads\nRx will miss in client cache, read from data from server\nclient will (probably) return ACK before T2 commits\nserver won't abort T2")]),e._v(" "),t("li",[e._v("invalidation arrives after T2 reads, before commit point\nclient will abort T2 in response to invalidation")]),e._v(" "),t("li",[e._v("invalidation arrives after 2PC commit point\ni.e. after all servers replied to prepare\nthis means the client was still in the invalid set when\nthe server tried to validate the transaction\nso the server aborted, so the client will abort too\nso: Thor's validation detects stale reads w/o timestamp on each record")])]),e._v(" "),t("p",[e._v("Performance")]),e._v(" "),t("p",[e._v("Look at Figure 5\nAOCC is Thor\ncomparing to ACBL: client talks to srvr to get write-locks,\nand to commit non-r/o xactions, but can cache read locks along with data\nwhy does Thor (AOCC) have higher throughput?\nfewer msgs; commit only, no lock msgs\nwhy does Thor throughput go up for a while w/ more clients?\napparently a single client can't keep all resources busy\nmaybe due to network RTT?\nmaybe due to client processing time? or think time?\nmore clients -> more parallel xactions -> more completed\nwhy does Thor throughput level off?\nmaybe 15 clients is enough to saturate server disk or CPU\nabt 100 xactions/second, about right for writing disk\nwhy does Thor throughput "),t("em",[e._v("drop")]),e._v(" with many clients?\nmore clients means more concurrent xactions at any given time\nmore concurrency means more chance of conflict\nfor OCC, more conflict means more aborts, so more wasted CPU")]),e._v(" "),t("p",[e._v("Conclusions\nfast client caching + transactions would be excellent\ndistributed OCC very interesting, still an open research area\navoiding per-record version #s doesn't seem compelling\nThor's use of time was influential, e.g. Spanner")])])}),[],!1,null,null,null);n.default=o.exports}}]);