(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{478:function(e,t,n){"use strict";n.r(t);var a=n(45),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_20-atomicity-two-phase-commit"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_20-atomicity-two-phase-commit"}},[e._v("#")]),e._v(" 20.Atomicity: Two-Phase Commit")]),e._v(" "),n("p",[e._v("Topics:\ndistributed commit, two-phase commit\ndistributed transactions\nArgus -- language for distributed programming")]),e._v(" "),n("p",[e._v('Distributed commit:\nA bunch of computers are cooperating on some task, e.g. bank transfer\nEach computer has a different role, e.g. src and dst bank account\nWant to ensure atomicity: all execute, or none execute\n"distributed transaction"\nChallenges: crashes and network failures')]),e._v(" "),n("p",[e._v("We've seen the fundamental problem before\nWhat to do if "),n("em",[e._v("part")]),e._v(" of a distributed computation crashes?\nIVY/Treadmarks had no answer\nMR/Spark could re-execute "),n("em",[e._v("part")]),e._v(" of computation, for big data\nWhat about for small updates?")]),e._v(" "),n("p",[e._v("Example:\ncalendar system, each user has a calendar\nwant to schedule meetings with multiple participants\none server holds calendars of users A-M, another server holds N-Z\n[diagram: client, two servers]\nsched(u1, u2, t):\nbegin_transaction\nok1 = reserve(u1, t)\nok2 = reserve(u2, t)\nif ok1 and ok2:\ncommit\nelse\nabort\nend_transaction\nthe reserve() calls are RPCs to the two calendar servers\nWe want both to reserve, or both not to reserve.\nWhat if 1st reserve() returns true, and then:\n2nd reserve() returns false (time not available)\n2nd reserve() doesn't return (lost RPC msg, u2's server crashes)\n2nd reserve() returns but then crashes\nclient fails before 2nd reserve()\nWe need a \"distributed commit protocol\"")]),e._v(" "),n("p",[e._v("Idea: tentative changes, later commit or undo (abort)\nreserve_handler(u, t):\nif u[t] is free:\ntemp_u[t] = taken -- A TEMPORARY VERSION\nreturn true\nelse:\nreturn false\ncommit_handler():\ncopy temp_u[t] to real u[t]\nabort_handler():\ndiscard temp_u[t]")]),e._v(" "),n("p",[e._v('Idea: single entity decides whether to commit\nto prevent any chance of disagreement\nlet\'s call it the Transaction Coordinator (TC)\n[time diagram: client, TC, A, B]\nclient sends RPCs to A, B\non end_transaction, client sends "go" to TC\nTC/A/B execute distributed commit protocol...\nTC reports "commit" or "abort" to client')]),e._v(" "),n("p",[e._v('We want two properties for distributed commit protocol:\nTC, A, and B start in state "unknown"\neach can move to state "abort" or "commit"\nbut then each never changes mind\nCorrectness:\nif any commit, none abort\nif any abort, none commit\nPerformance:\n(since doing nothing is correct...)\nif no failures, and A and B can commit, then commit.\nif failures, come to some conclusion ASAP.')]),e._v(" "),n("p",[e._v('We\'re going to develop a protocol called "two-phase commit"\nUsed by distributed databases for multi-server transactions\nAnd by Spanner and Argus')]),e._v(" "),n("p",[e._v('Two-phase commit without failures:\n[time diagram: client, TC, A, B]\nclient sends reserve() RPCs to A, B\nclient sends "go" to TC\nTC sends "prepare" messages to A and B.\nA and B respond, saying whether they\'re willing to commit.\nRespond "yes" if haven\'t crashed, timed out, &c.\nIf both say "yes", TC sends "commit" messages.\nIf either says "no", TC sends "abort" messages.\nA/B "decide to commit" if they get a commit message.\nI.e. they actually modify the user\'s calendar.')]),e._v(" "),n("p",[e._v("Why is this correct so far?\nNeither can commit unless they both agreed.\nCrucial that neither changes mind after responding to prepare\nNot even if failure")]),e._v(" "),n("p",[e._v("What about failures?\nNetwork broken/lossy\nServer crashes\nBoth visible as timeout when expecting a message.")]),e._v(" "),n("p",[e._v("Where do hosts wait for messages?")]),e._v(" "),n("ol",[n("li",[e._v("TC waits for yes/no.")]),e._v(" "),n("li",[e._v("A and B wait for prepare and commit/abort.")])]),e._v(" "),n("p",[e._v("Termination protocol summary:\nTC t/o for yes/no -> abort\nB t/o for prepare, -> abort\nB t/o for commit/abort, B voted no -> abort\nB t/o for commit/abort, B voted yes -> block")]),e._v(" "),n("p",[e._v('TC timeout while waiting for yes/no from A/B.\nTC has not sent any "commit" messages.\nSo TC can safely abort, and send "abort" messages.')]),e._v(" "),n("p",[e._v('A/B timeout while waiting for prepare from TC\nhave not yet responded to prepare\nso can abort\nrespond "no" to future prepare')]),e._v(" "),n("p",[e._v('A/B timeout while waiting for commit/abort from TC.\nLet\'s talk about just B (A is symmetric).\nIf B voted "no", it can unilaterally abort.\nSo what if B voted "yes"?\nCan B unilaterally decide to abort?\nNo! TC might have gotten "yes" from both,\nand sent out "commit" to A, but crashed before sending to B.\nSo then A would commit and B would abort: incorrect.\nB can\'t unilaterally commit, either:\nA might have voted "no".')]),e._v(" "),n("p",[e._v('If B voted "yes", it must "block": wait for TC decision.')]),e._v(" "),n("p",[e._v('What if B crashes and restarts?\nIf B sent "yes" before crash, B must remember!\n--- this is today\'s question\nCan\'t change to "no" (and thus abort) after restart\nSince TC may have seen previous yes and told A to commit\nThus:\nB must remember on disk before saying "yes", including modified data.\nB reboots, disk says "yes" but no "commit", must ask TC.\nIf TC says "commit", copy modified data to real data.')]),e._v(" "),n("p",[e._v('What if TC crashes and restarts?\nIf TC might have sent "commit" or "abort" before crash, TC must remember!\nAnd repeat that if anyone asks (i.e. if A/B/client didn\'t get msg).\nThus TC must write "commit" to disk before sending commit msgs.\nCan\'t change mind since A/B/client have already acted.')]),e._v(" "),n("p",[e._v('This protocol is called "two-phase commit".\nWhat properties does it have?')]),e._v(" "),n("ul",[n("li",[e._v("All hosts that decide reach the same decision.")]),e._v(" "),n("li",[e._v('No commit unless everyone says "yes".')]),e._v(" "),n("li",[e._v("TC failure can make servers block until repair.")])]),e._v(" "),n("p",[e._v("What about concurrent transactions?\nWe realy want atomic distributed transactions,\nnot just single atomic commit.\nx and y are bank balances\nx and y start out as $10\nT1 is doing a transfer of $1 from x to y\nT1:\nadd(x, 1)  -- server A\nadd(y, -1) -- server B\nT2:\ntmp1 = get(x)\ntmp2 = get(y)\nprint tmp1, tmp2")]),e._v(" "),n("p",[e._v("Problem:\nwhat if T2 runs between the two add() RPCs?\nthen T2 will print 11, 10\nmoney will have been created!\nT2 should print 10,10 or 9,11")]),e._v(" "),n("p",[e._v('The traditional approach is to provide "serializability"\nresults should be as if transactions ran one at a time in some order\neither T1, then T2; or T2, then T1')]),e._v(" "),n("p",[e._v("Why serializability?\nit allows transaction code to ignore the possibility of concurrency\njust write the transaction to take system from one legal state to another\ninternally, the transaction can temporarily violate invariants\nbut serializability guarantess no-one will notice")]),e._v(" "),n("p",[e._v('One way to implement serializabilty is with "two-phase locking"\nthis is what Argus does\neach database record has a lock\nthe lock is stored at the server that stores the record\nno need for a central lock server\neach use of a record automatically acquires the record\'s lock\nthus add() handler implicitly acquires lock when it uses record x or y\nlocks are held until '),n("em",[e._v("after")]),e._v(" commit or abort")]),e._v(" "),n("p",[e._v("Why hold locks until after commit/abort?\nwhy not release as soon as done with the record?\ne.g. why not have T2 release x's lock after first get()?\nT1 could then execute between T2's get()s\nT2 would print 10,9\nbut that is not a serializable execution: neither T1;T2 nor T2;T1")]),e._v(" "),n("p",[e._v("2PC perspective\nUsed in sharded DBs when a transaction uses data on multiple shards\nBut it has a bad reputation:\nslow because of multiple phases / message exchanges\nlocks are held over the prepare/commit exchanges\nTC crash can cause indefinite blocking, with locks held\nThus usually used only in a single small domain\nE.g. not between banks, not between airlines, not over wide area")]),e._v(" "),n("p",[e._v("Paxos and two-phase commit solve different problems!\nUse Paxos to high availability by replicating\ni.e. to be able to operate when some servers are crashed\nthe servers must have identical state\nUse 2PC when each participant does something different\nAnd "),n("em",[e._v("all")]),e._v(" of them must do their part\n2PC does not help availability\nsince all servers must be up to get anything done\nPaxos does not ensure that all servers do something\nsince only a majority have to be alive")]),e._v(" "),n("p",[e._v("What if you want high availability "),n("em",[e._v("and")]),e._v(' distributed commit?\n[diagram]\nEach "server" should be a Paxos-replicated service\nAnd the TC should be Paxos-replicated\nRun two-phase commit where each participant is a replicated service\nThen you can tolerate failures and still make progress\nThis is what Spanner does (for update transactions)')]),e._v(" "),n("p",[e._v("Case study: Argus")]),e._v(" "),n("p",[e._v('Argus\'s big ideas:\nLanguage support for distributed programs\nVery cool: language abstracts away ugly parts of distrib systems\nAimed at services interacting via RPC\nClean handling of RPC and server failure\nTransactional updates via 2PC\nSo crash results in entire transaction un-done, not partial update\nEasy persistence ("stable"):\nOrdinary variables automatically persisted to disk\nAutomatic crash recovery\nEasy concurrency control:\nMultiple clients means multiple distributed transactions\nAutomatic locking of language objects')]),e._v(" "),n("p",[e._v("The overall design story seems very sensible\nStarting point: you want to handle RPC failures cleanly\nClean failure handling means Argus needs transactions\nTransaction roll-back means Argus must manage program objects\nCrash recovery means Argus must handle persisting program objects")]),e._v(" "),n("p",[e._v('Picture\n"guardian" is like an RPC server\nhas state (variables) and handlers\n"handler" is an RPC handler\nreads and writes local variables\n"action" is a distributed atomic transaction\naction on A\nA RPC to B\nB RPC to C\nA RPC to D\nA finishes action\nprepare msgs to B, C, D\ncommit msgs to B, C, D')]),e._v(" "),n("p",[e._v("The style is to send RPC to where the data is\nNot to fetch the data\nArgus is not a storage system")]),e._v(" "),n("p",[e._v("Look at bank example\npage 309 (and 306): bank transfer")]),e._v(" "),n("p",[e._v("Points to notice\nstable keyword (programmer never writes to disk &c)\natomic keyword (programmer almost never locks/unlocks)\nenter topaction (in transfer)\ncoenter (in transfer)\nRPCs are hidden (e.g. f.withdraw())\nRPC error handling hidden (just aborts)")]),e._v(" "),n("p",[e._v("what if deposit account doesn't exist?\nbut f.withdraw(from) has already been called?\nhow to un-do?\nwhat's the guardian state when withdraw() handler returns?\nlock, temporary version, just in memory")]),e._v(" "),n("p",[e._v("what if an audit runs during a transfer?\nhow does the audit not see the tentative new balances?")]),e._v(" "),n("p",[e._v("if a guardian crashes and reboots, what happens to its locks?\ncan it just forget about pre-crash locks?")]),e._v(" "),n("p",[e._v("subactions\neach RPC is actually a sub-action\nthe RPC can fail or abort w/o aborting surrounding action\nthis lets actions e.g. try one server, then another\nif RPC reply lost, subaction will abort, undo\nmuch cleaner than e.g. Go RPC")]),e._v(" "),n("p",[e._v("is Argus's implicit locking the right thing?\nvery convenient!\ndon't have to worry about forgetting to lock!\n(though deadlocks are easy)\ndatabases work (and worked) this way; it's a sucessful idea")]),e._v(" "),n("p",[e._v("is transactions + RPC + 2PC a good design point?\nprogrammability pro:\nvery easy to get nice fault tolerance semantics\nperformance con:\nlots of msgs and disk writes\n2PC and 2PL hold locks for a while, block if failure")]),e._v(" "),n("p",[e._v("is Argus's language integration the right thing?\ni.e. persisting and locking language objects\nit looks very convenient (and it is)")]),e._v(" "),n("p",[e._v("why didn't more systems pick up on Argus' language-based approach?\nJava RMI is perhaps the closest in common use\nperhaps people prefer to build distributed systems around data\nnot around RPC\ne.g. big web sites are very storage-centric\ndatabase provides transactions, persistence, &c\ntables, records, and queries are more powerful than Argus' data\nmaybe there is a better language-based scheme waiting to be found")])])}),[],!1,null,null,null);t.default=s.exports}}]);