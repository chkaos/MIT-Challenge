(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{469:function(e,n,s){"use strict";s.r(n);var t=s(45),o=Object(t.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"_11-disconnected-operation-version-vectors-and-file-synchronization"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-disconnected-operation-version-vectors-and-file-synchronization"}},[e._v("#")]),e._v(" 11.Disconnected Operation: Version Vectors and File Synchronization")]),e._v(" "),s("p",[e._v("6.824 2015 Lecture 11: Optimism, Causality, Vector Timestamps")]),e._v(" "),s("p",[e._v("Consistency so far\nConcurrency forces us to to think about meaning of reads/writes\ne.g. if P1 has seen P2's write, has P3 seen P2's write too?\nSequential consistency: everyone sees same read/write order (IVY)\nRelease consistency: everyone sees writes in unlock order (TreadMarks)")]),e._v(" "),s("p",[e._v("Sequential and release consistency require central component:\nmust ask before each operation to ensure ordering\nIVY: read faults and write faults -> ask page's manager\nTreadMarks: acquire and release -> ask lock manager")]),e._v(" "),s("p",[e._v("Central component can be undesirable\nBottleneck, single point of failure, requires network connectivity\nCan we get rid of it?")]),e._v(" "),s("p",[e._v("Starting a new class of distributed systems:\nNo central component\nSupport disconnected or partially connected operation\nUse optimistic approach (always allow, clean up later)\nProvide eventual and causal consistency")]),e._v(" "),s("p",[e._v("Example -- peer-to-peer chat\nWe each have a computer attached to internet\nCan send at any time (optimistic), no central ordering\nRecv msg -> add to end of chat window")]),e._v(" "),s("p",[e._v("Do we care about message ordering for chat?\nNetwork may deliver in different order at different participants\nSuppose Alice is auctioning something\nJoe: $10\nFred: $20\nAlice: the high bid is $20\nMaybe Sam sees:\nJoe: $10\nAlice: the high bid is $20")]),e._v(" "),s("p",[e._v("What went wrong in this example?\nAlice \"computed\" her message based on certain inputs\nOnly makes sense to Sam if he has seen those inputs too\nWhy not have Alice's message describe what Alice had seen?\nCould fix Sam's order w/o requiring central component")]),e._v(" "),s("p",[e._v('Definition: x causally precedes y\nx precedes y if:\nM0 does x, then M0 does y\nM0 does x, M0 sends msg to M1, M1 does y\ntransitive closure\nx and y could be writes, or msgs, or file versions\nalso "y causally depends on x"')]),e._v(" "),s("p",[e._v("Definition: causal consistency\nif x causally precedes y, everyone sees x before y")]),e._v(" "),s("p",[e._v("Pro: we can implement w/o central component\nCon: not a total order -- some events have no relative order")]),e._v(" "),s("p",[e._v('Slow implementation of causal consistency\nUnique ID for every msg\nNode keeps set of all msg IDs received -- "history"\nWhen sending m, send current history set, too\nReceiver delays incoming msg m until has received everything in m\'s set')]),e._v(" "),s("p",[e._v("History sets will grow huge -- can we abbreviate?\nEach node numbers its msgs 1, 2, 3, &c\nEach message carries a vector:\n[ 4, 3, 7 ]\nMeans sender had seen through msg 4 from H0, 3 from H1, 7 from H2\nThis notation doesn't grow over time, unlike history sets\nCalled a Vector Timestamp or Version Vector\nVTi[j] = x means host i has seen all of j's messages through x")]),e._v(" "),s("p",[e._v('VT comparisons\nto answer "should msg A be displayed before msg B?"\na < b if:\nforall i: a[i] <= b[i]  AND  exists j: a[j] < b[j]\ni.e. a summarizes a proper prefix of b\ni.e. a causally precedes b\na || b if:\nexists i,j: a[i] < b[i] and a[j] > b[j]\ni.e. neither summarizes a prefix of the other\ni.e. neither causally precedes the other')]),e._v(" "),s("p",[e._v('Many systems use VT variants, but for somewhat different purposes\nTreadMarks, Ficus, Bayou, Dynamo, &c\n"I\'ve seen everyone\'s updates up to this point"\n"event x preceded event y"\nVTs are compact and decentralized')]),e._v(" "),s("p",[e._v('Example use of VTs: CBCAST -- "causal broadcast" protocol\nGeneral-purpose ordering protocol, e.g. for peer-to-peer chat\nFrom Cornell Isis research project\nKey property:\nDelivers messages to individual nodes in causal order\nIf a causally precedes b, CBCAST delivers a first\n[diagram: node, msg buf, VC, chat app]\nEach node keeps a local vector clock, VC\nVCi[j] = k means app at node i has seen all msgs from j up through k\nsend(m) at node i:\nVCi[i] += 1\nbroadcast(m, i, VCi)\non receipt of broadcast(m, i, v) at node j:\nj\'s CBCAST library buffers the message\nrelease to application only when:\nVCj >= v, except v[i] = VCj[i] + 1\ni.e. node j has seen every msg that causally precedes m\nVCj[i] = v[i]\nso sends will reflect receipt of m')]),e._v(" "),s("p",[e._v("Example:\nAll VCs start <0,0,0>\nM0 sends <1,0,0>\nM1 receives <1,0,0>\nM1 sends <1,1,0>\nM2 receives <1,1,0> -- must delay\nM2 receives <1,0,0> -- can process, unblocks other msg")]),e._v(" "),s("p",[e._v("Why fast?\nNo central manager, no global order\nIf no causal dependencies, CBCAST doesn't delay messages\nExample:\nM0 sends <1,0>\nM1 sends <0,1>\nReceivers are allowed to deliver in either order")]),e._v(" "),s("p",[e._v("Causal consistency still allows more surprises than sequential\nOnly causally related events are ordered\nSo nodes can disagree on order of non-dependent events\nSam can still see:\nJoe: $10\nFred: $20\nBob: $30\nAlice: the high bid is $20\nCausal consistency only says Alice's msg will be delivered after\nall msgs she had seen when she sent it\n"),s("em",[e._v("Not")]),e._v(" that it will be delivered before all msgs she hadn't seen")]),e._v(" "),s("p",[e._v("TreadMarks uses VTs to order writes to same variable by different machines:\nM0: a1 x=1 r1  a2 y=9 r2\nM1:              a1 x=2 r1\nM2:                           a1 a2 z = x + y r2 r1\nCould M2 hear x=2 from M1, then x=1 from M0?\nHow does M2 know what to do?")]),e._v(" "),s("p",[e._v('VTs are often used for optimistic updating of replicated data\nEveryone has a copy, anyone can write\nDon\'t want IVY-style MGR or locking: network delays, failures\nNeed to sync replicas, accept only "newest" data, detect conflicts\nFile sync (Ficus, Coda, Rumor)\nDistributed DBs (Amazon Dynamo, Voldemort, Riak)')]),e._v(" "),s("p",[e._v('File synchronization -- e.g. Ficus\nMultiple computers have a copy of all files\nThey can\'t always talk to each other ("disconnected operation")\nUser can always modify local copy of file -- optimistic\nMerge changes later')]),e._v(" "),s("p",[e._v("Scenario:\nuser has files replicated at work, at home, on laptop\nhosts may be disconnected: no WiFi, turned off\nedit on H1 for a while, sync changes to H2\nedit on H2, sync changes to H3\nedit on H3, sync to H1")]),e._v(" "),s("p",[e._v("Goa: eventual consistency\ni.e. replicas often differ, but converge after enough syncs")]),e._v(" "),s("p",[e._v("Goal: no lost updates\nOnly OK for sync to copy version v2 over version v1 if\nv2 includes all updates that are in v1.")]),e._v(" "),s("p",[e._v("Example 1:\nFocus on a single file\nH1: f=1 ->H2       ->H3\nH2:            f=2\nH3:                       ->H2\nWhat is the right thing to do?\nIs it enough to simply take file with latest modification time?\nYes in this case, as long as you carry them along correctly.\nI.e. H3 remembers mtime assigned by H1, not mtime of sync.")]),e._v(" "),s("p",[e._v("Example 2:\nH1: f=1 ->H2 f=2\nH2:                  f=0 ->H1\nH2's mtime will be bigger.")]),e._v(" "),s("p",[e._v('Should the file synchronizer use "0" and discard "2"?\nAfter all, f=0 was a later update than f=2.\nNo: that would violate the No Lost Updates goal.\nE.g. you and I both made changes to the file.')]),e._v(" "),s("p",[e._v('What do do if concurrent updates to the same data?\nSync should somehow detect this "conflict" situation.\nSometimes conflicts can be automatically resolved once detected.\nSometimes the user has to figure out how to resolve.\nConflicts are a necessary consequence of optimistic writes.')]),e._v(" "),s("p",[e._v("How to decide if version v2 contains all of v1's updates?\nI.e. when no updates would be lost by replacing v1 with v2.\nWe could record each file's entire modification history.\nList of hostname/localtime pairs.\nAnd carry history along when synchronizing between hosts.\nFor example 1:   H2: H1/T1,H2/T2   H3: H1/T1\nFor example 2:   H1: H1/T1,H1/T2   H2: H1/T1,H2/T3\nThen its easy to decide if version X supersedes version Y:\nIf Y's history is a prefix of X's history.")]),e._v(" "),s("p",[e._v("We can use VTs to compress these histories!\nEach host remembers a VT per file\nNumber each host's writes to a file (or assign wall-clock times)\nJust remember # of last write from each host\nVT[i]=x => file version includes all of host i's updates through #x")]),e._v(" "),s("p",[e._v("VTs for Example 1:\nAfter H1's change: v1=<1,0,0>\nAfter H2's change: v2=<1,1,0>\nv1 < v2, so H2 ignores H3's copy (no conflict since <)\nv2 > v1, so H1/H3 would accept H2's copy (again no conflict)")]),e._v(" "),s("p",[e._v("VTs for Example 2:\nAfter H1's first change: v1=<1,0,0>\nAfter H1's second change: v2=<2,0,0>\nAfter H2's change: v3=<1,1,0>\nv3 neither < nor > v1\nthus neither has seen all the other's updates\nthus there's a conflict")]),e._v(" "),s("p",[e._v("What if there "),s("em",[e._v("are")]),e._v(" conflicting updates?\nVTs can detect them, but then what?\nDepends on the application.\nEasy: mailbox file with distinct immutable messages, just union.\nMedium: changes to different lines of a C source file (diff+patch).\nHard: changes to the same line of C source.\nReconciliation must be done manually for the hard cases.\nToday's paper is all about reconciling conflicts")]),e._v(" "),s("p",[e._v("How to think about VTs for file synchronization?\nThey detect whether there was a serial order of versions\nI.e. when I modified the file, had I already seen your modification?\nIf yes, no conflict\nIf no, conflict\nOr:\nA VT summarizes a file's complete version history\nThere's no conflict if your version is a prefix of my version")]),e._v(" "),s("p",[e._v("What about file deletion?\nCan H1 just forget a file's VT if it deletes the file?\nNo: when H1 syncs w/ H2, it will look like H2 has a new file.\nH1 must remember deleted files' VTs.\nTreat delete like a file modification.\nH1: f=1  ->H2\nH2:           del  ->H1\nsecond sync sees H1:<1,0> H2<1,1>, so delete wins at H1\nThere can be delete/write conflicts\nH1: f=1  ->H2  f=2\nH2:            del  ->H1\nH1:<2,0> vs H2:<1,1> -- conflict\nIs it OK to delete at H1?")]),e._v(" "),s("p",[e._v("Can a node ever discard a deleted file's VT?\nSimilar danger: discard VT, then sync w/ node that didn't discard.")]),e._v(" "),s("p",[e._v("How Ficus forgets about a deleted file's VT\nH1: del f ->all seen f->all  done f->all   forget f\nH2:             seen f->all  done f->all   forget f\nH3:             seen f->all  done f->all   forget f\n|-- phase 1 -----------|-- phase 2 --|\nPhase 1: accumulate set of nodes that have seen delete\nterminates when == complete set of nodes\nPhase 2: accumulate set of nodes that have completed Phase 1\nwhen == all nodes, can totally forget the file\nIf H1 then syncs against H2,\nH2 must be in Phase 2, or completed Phase 2\nif in Phase 2, H2 knows H1 once saw the delete, so need not tell H1 abt file\nif H2 has completed Phase 2, it doesn't know about the file either")]),e._v(" "),s("p",[e._v("A classic problem with VTs:\nMany hosts -> big VTs\nEasy for VT to be bigger than the data!\nNo very satisfying solution")]),e._v(" "),s("p",[e._v("Many file synchronizers don't use VTs -- e.g. Unison, rsync\nFile modification times are enough if only two parties, or star\nNeed to remember time of last sync, time of modification\nConflict if both nodes' modification times are greater than last sync\nVTs needed if you want any-to-any sync with > 2 hosts")]),e._v(" "),s("p",[e._v("Summary\nReplication + optimistic updates for speed, high availability\nCausal consistency yields sane order of optimistic updates (CBCAST)\nVector Timestamps detect conflicting updates\nby compactly summarizing update histories")])])}),[],!1,null,null,null);n.default=o.exports}}]);