(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{433:function(t,a,e){"use strict";e.r(a);var s=e(45),i=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_9-mutability-immutability"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-mutability-immutability"}},[t._v("#")]),t._v(" 9. Mutability & Immutability")]),t._v(" "),e("h3",{attrs:{id:"可变性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可变性"}},[t._v("#")]),t._v(" 可变性")]),t._v(" "),e("p",[t._v("Some objects are mutable : they have methods that change the value of the object.")]),t._v(" "),e("h3",{attrs:{id:"可变性的风险"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可变性的风险"}},[t._v("#")]),t._v(" 可变性的风险")]),t._v(" "),e("p",[t._v("不可变的类型更安全，更容易理解，更易于更改;")]),t._v(" "),e("p",[t._v("传递/返回 可变类型值都是为程序增加了不稳定性;\naliases: 对于同一可变对象有多个引用存在风险")]),t._v(" "),e("h3",{attrs:{id:"可变性与合约"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可变性与合约"}},[t._v("#")]),t._v(" 可变性与合约")]),t._v(" "),e("ul",[e("li",[t._v("Mutable objects can make simple contracts very complex")]),t._v(" "),e("li",[t._v("Mutable objects reduce changeability")])]),t._v(" "),e("h3",{attrs:{id:"useful-immutable-types"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#useful-immutable-types"}},[t._v("#")]),t._v(" Useful immutable types")]),t._v(" "),e("h3",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("这里的关键设计原则是 不变性 ：尽可能使用不变的对象和不变的引用。让我们回顾一下不变性如何帮助实现本课程的主要目标：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("安全的错误: 不可变的对象不易受到别名引起的错误的影响。不可变的引用始终指向同一对象。")])]),t._v(" "),e("li",[e("p",[t._v("容易理解: 由于不可变的对象或引用始终意味着同一件事，因此代码阅读者可以更轻松地进行推理-他们不必遍历所有代码来查找可能更改对象或引用的所有位置，因为它无法更改。")])]),t._v(" "),e("li",[e("p",[t._v("准备改变: 如果不能在运行时更改对象或引用，则在程序更改时不必修改依赖于该对象或引用的代码。")])])])])}),[],!1,null,null,null);a.default=i.exports}}]);