(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{435:function(t,a,s){"use strict";s.r(a);var e=s(45),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_14-interfaces"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-interfaces"}},[t._v("#")]),t._v(" 14. Interfaces")]),t._v(" "),s("p",[t._v("interface 是一种用于表达抽象数据类型的有用语言机制")]),t._v(" "),s("h3",{attrs:{id:"subtypes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#subtypes"}},[t._v("#")]),t._v(" Subtypes")]),t._v(" "),s("p",[t._v("接口继承, 子集之类的, golang 无")]),t._v(" "),s("h3",{attrs:{id:"why"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#why"}},[t._v("#")]),t._v(" why")]),t._v(" "),s("ul",[s("li",[t._v("编译器和人类的文档: 接口不仅可以帮助编译器捕获ADT实现的错误，而且对于人类而言，比起具体实现的代码，它还更加有用。这样的实现将ADT级别的类型和规范散布在实现细节中。")]),t._v(" "),s("li",[t._v("允许性能折衷: ADT的不同实现方式可以提供具有非常不同的性能特征的方法。不同的应用程序在不同的选择下可能会更好地工作，但是我们希望以独立于表示的方式对这些应用程序进行编码。从正确性的角度来看，应该可以使用简单的本地化代码更改来添加任何新的密钥ADT实现。")]),t._v(" "),s("li",[t._v("可选方法:  List Java标准库中的标记将所有mutator方法标记为可选。通过构建不支持这些方法的实现，我们可以提供不可变的列表。有些操作难以在不可变列表上以足够好的性能实现，因此我们也希望实现可变的实现。可以将不调用mutator的代码编写为可自动使用两种列表。\n规范故意欠缺的方法: 有限集的ADT在转换为列表时可能未指定元素顺序。某些实现可能使用较慢的方法实现，这些实现设法将集合表示保持在某种排序的顺序，从而允许快速转换为排序的列表。其他实现可能不麻烦地支持转换为排序列表，从而使许多方法更快。")]),t._v(" "),s("li",[t._v("类的多种实现: Java类可以实现多种方法。例如，显示下拉列表的用户界面窗口小部件自然既可以作为窗口小部件又可以作为列表来查看。该小部件的类可以实现两个接口。换句话说，我们不会因为选择不同的数据结构而多次实现ADT。我们可以进行多种实现，因为除其他有用的观点外，许多不同种类的对象也可能被视为ADT的特殊情况。\n越来越值得信赖的实现: 多次实现接口的另一个原因可能是，您很容易构建一个您认为正确的简单实现，而您可以更努力地构建一个更可能包含错误的高级版本。您可以根据被错误咬的严重程度来选择应用程序的实现。")])]),t._v(" "),s("h3",{attrs:{id:"概要"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概要"}},[t._v("#")]),t._v(" 概要")]),t._v(" "),s("ul",[s("li",[t._v("避免错误: ADT由其操作定义，而接口正是通过其操作来定义的。客户端使用接口类型时，静态检查可确保它们仅使用接口定义的方法。如果实现类公开了其他方法（或更糟的是具有可见的表示形式），则客户端不会偶然看到或依赖它们。当我们有一个数据类型的多个实现时，接口提供对方法签名的静态检查。")]),t._v(" "),s("li",[t._v("容易明白: 客户和维护人员确切知道在哪里可以找到ADT的规范。由于该接口不包含实例字段或实例方法的实现，因此将实现的细节保留在规范之外会更加容易。")]),t._v(" "),s("li",[t._v("准备好进行更改: 通过添加实现接口的类，我们可以轻松地添加类型的新实现。如果我们避免使用构造函数支持静态工厂方法，则客户端只会看到该接口。这意味着我们可以切换客户端使用的实现类，而根本无需更改其代码。")])])])}),[],!1,null,null,null);a.default=r.exports}}]);