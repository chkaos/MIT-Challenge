# 24. Graphical User Interfaces

- the view tree, which is a central feature in the architecture of every important GUI toolkit;
- the model-view-controller pattern, which separates input, output, and data;
- the listener pattern, which is essential to decoupling the model from the view and controller.

### 视图树
图形用户界面由视图对象组成，每个对象占据屏幕的某一部分，通常为矩形区域，称为其边界框。

视图树。视图被排列成包含层次结构，其中某些视图包含其他视图。典型的容器是窗口、面板和工具栏。视图树不仅仅是一个任意层次结构，而是一个空间层次结构：子视图嵌套在父级边界框中。

在 HTML 中，它们是元素或节点;

几乎每个 GUI 系统都有某种视图树。视图树是一种强大的结构理念：

- 输出:视图负责显示自身，视图树指示显示过程。GU 通过更改视图树来更改其输出。例如，若要在相册 GUI 中显示一组新照片，将从视图树中删除当前缩略图，并在其位置添加一组新的缩略图。GUI 工具包中内置的重绘算法会自动重绘子树中受影响的部分。在 Java Swing 中，树中的每个视图都有一个知道如何在屏幕上绘制自己的方法。重绘过程由调用树根驱动，该根递归地通过视图树的所有后代节点向下调用。
- 输入: 视图可以具有输入处理程序，视图树控制处理鼠标和键盘输入的过程。
- 布局: 视图树控制视图在屏幕上的布局，即如何分配其边界框。自动布局算法自动计算视图的位置和大小。专用容器自己进行布局。更通用的容器将布局决策委托给布局管理器;

### Input Handling

在GUI中，输入的处理方式与我们在解析器和服务器中处理的输入有些不同。在这些系统中，我们看到一个解析器，它剥离了输入，并决定如何引导它到程序的不同模块。

在 GUI 中，我们不会直接编写此类方法，因为它不是模块化的。它将按钮、列表框和文本框的职责混合在一个位置。相反，GUI利用视图树提供的空间分离，同时提供功能分离。鼠标单击和键盘事件分布在视图树周围，具体取决于它们发生的位置。

GUI 输入事件处理是侦听器模式（也称为发布-订阅）的实例。在侦听器模式中：

- 事件源生成离散事件流，这些事件对应于源中的状态转换。
- 一个或多个侦听器对事件流进行兴趣（订阅）登记，提供在发生新事件时要调用的函数。
在这种情况下，鼠标是事件源，事件是鼠标状态的变化：其 x，y 位置或按钮的状态（无论它们是按下还是释放）。事件通常包括有关转换的其他信息（如鼠标的 x，y 位置），这些信息可能会捆绑到事件对象中或作为参数传递。

发生事件时，事件源通过调用其回调方法将其分发给所有已订阅的侦听器。

通过图形用户界面的控制流继续这样进行：

- 顶级事件循环读取来自鼠标和键盘的输入。
- 对于每个输入事件，以点击事件为例，它会在树中查找正确的视图（通过查看鼠标的 x，y 位置），并将事件发送到该视图的侦听器。
- 每个侦听器执行其操作（这可能涉及修改视图树中的对象），然后立即返回到事件循环。
最后一部分 （侦听器尽可能快地返回到事件循环 ） 非常重要，因为它保留了用户界面的响应能力。

侦听器模式不仅用于低级别输入事件，如鼠标单击和键盘按键。许多 GUI 对象生成自己的较高级别事件，通常是由于低级输入事件的某种组合。例如：

鼠标（鼠标向下并按下鼠标）或键盘（对于不能使用鼠标的用户（如盲人用户）可以按下按钮。因此，您应该始终侦听这些高级事件，而不是低级输入事件。使用监听器来响应按键。

### 前后端分离

MVC(模型-视图-控制器模式)将这种关注点分离作为主要目标。它将用户界面前端与应用程序后端分离，将后端代码放入模型，将前端代码放入视图和控制器中。MVC 还将输入与输出分离;控制器应该处理输入，视图应该处理输出。

该模型负责维护特定于应用程序的数据并提供对该数据的访问。模型通常是可变的，它们提供了安全更改状态的方法，保留了其表示不变量。好的，所有可变对象都这样做。但是，当其数据发生更改时，模型还必须通知其客户端，以便从属视图可以更新其显示，并且从属控制器可以适当响应。模型使用侦听器模式进行此通知，其中感兴趣的视图和控制器将自己注册为模型生成的更改事件的侦听器。

视图对象负责输出。视图通常占据屏幕的一些块，通常是矩形区域。基本上，视图查询数据模型并在屏幕上绘制数据。它侦听模型中的更改，以便可以更新屏幕以反映这些更改。

最后，控制器处理输入。它接收键盘和鼠标事件，并指示模型相应地更改。

当然，各种现代前端框架根据 controller 组织方式的不同，衍生出来各种 mv*(Vue)，其实说到底，都是一个东西。

### 总结
- 视图树将屏幕组织成嵌套矩形树，并用于调度输入事件以及显示输出。
- 侦听器模式向已注册的侦听器发送事件流（如鼠标或键盘事件或按钮操作事件）。
- 模型-视图-控制器模式区分了职责：模型=数据、视图=输出、控制器=输入。
- 长时间运行的处理应移动到后台线程，但 Swing 视图树仅限于事件调度线程。因此，从另一个线程访问 Swing 对象需要使用事件循环作为消息传递队列，才能返回事件调度线程。