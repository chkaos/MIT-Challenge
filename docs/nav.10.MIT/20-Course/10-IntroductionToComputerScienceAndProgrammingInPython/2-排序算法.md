# Sorting Algorithms

#### 冒泡排序

#### 选择排序

选择排序是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。

```go
func selectionSort(L []int) {
	var n = len(L)
	for i := 0; i < n; i++ {
		var minIdx = i
		for j := i + 1; j < n; j++ {
			if L[j] < L[minIdx] {
				minIdx = j
			}
		}
		L[i], L[minIdx] = L[minIdx], L[i]
	}
}
```
选择排序的交换操作介于0和`(n-1)`次之间。选择排序的比较操作为`n(n-1)/2}n(n-1)/2`次。选择排序的赋值操作介于`0`和`3(n-1)}3(n-1)`次之间。

比较次数`O(n^{2})`，比较次数与关键字的初始状态无关，总的比较次数`(n-1)/2}N=(n-1)+(n-2)+...+1=n\times (n-1)/2`。交换次数`O(n)`，最好情况是，已经有序，交换0次；最坏情况是，逆序，交换n-1次。交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。

> 原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。

#### 归并排序
- 分割: 递归地把当前数组平均分割成两半
- 集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）

归并排序使用分而治之的思想，以折半的方式来递归/迭代排序元素，利用空间来换时间，做到了时间复杂度 `O(n·log(n))` 的同时保持了稳定.

这让它在一些更考虑排序效率和稳定性，次考虑存储空间的场合非常适用（如数据库内排序）。和堆排序相比有同样的时间复杂度, 但是堆排序的O(1)辅助空间显然更胜一筹, 但是归并排序的稳定是优点, 且归并排序非常适合于链表排序。

```go
func mergeSort(L []int) []int {
	if len(L) <= 1 {
		return L
	}
	//递[归]
	middle := len(L) / 2
	//不断地进行左右对半划分
	left := mergeSort(L[:middle])
	right := mergeSort(L[middle:])
	//合[并]
	return merge(left, right)
}

func merge(left, right []int) []int{
	newArr := make([]int, len(left)+len(right))
	i, j, index :=0,0,0
	for {
		if left[i] > right[j] {
			newArr[index] = right[j]
			index++
			j++
			if j == len(right) {
				copy(newArr[index:], left[i:])
				break
			}

		}else{
			newArr[index] = left[i]
			index++
			i++
			if i == len(left) {
				copy(newArr[index:], right[j:])
				break
			}
		}
	}
	return newArr
}
```

传入排序方法版本的归并排序, 由于Go语言不支持默认参数, 所以实现起来会有点不优雅, 暂且用参数 struct 来实现默认排序方法

```go
type MergeConf struct {
	L       []int
	Compare func(int, int) bool
}

func mergeSort2(conf MergeConf) []int {
	if len(conf.L) <= 1 {
		return conf.L
	}

	if conf.Compare == nil {
		conf.Compare = func(a, b int) bool {
			return a > b
		}
	}
	//递[归]
	middle := len(conf.L) / 2
	//不断地进行左右对半划分
	leftConf := MergeConf{L: conf.L[:middle], Compare: conf.Compare}
	rightConf := MergeConf{L: conf.L[middle:], Compare: conf.Compare}
	left := mergeSort2(leftConf)
	right := mergeSort2(rightConf)
	//合[并]
	return merge2(left, right, conf.Compare)
}

func merge2(left, right []int, compare func(int, int) bool) []int {
	newArr := make([]int, len(left)+len(right))
	i, j, index := 0, 0, 0
	for {
		if compare(left[i], right[j]) {
			newArr[index] = right[j]
			index++
			j++
			if j == len(right) {
				copy(newArr[index:], left[i:])
				break
			}

		} else {
			newArr[index] = left[i]
			index++
			i++
			if i == len(left) {
				copy(newArr[index:], right[j:])
				break
			}
		}
	}
	return newArr
}
```
#### 插入排序

#### 希尔排序

#### 堆排序

#### 快速排序

## 排序算法比较

|          	| worst-case               	| best case                     	| Average                  	| Worst-case space complexity 	| 特点     	|
|----------	|--------------------------	|-------------------------------	|--------------------------	|-----------------------------	|----------	|
| 选择排序 	| O(n^2) 比较<br>О(n) 交换 	| O(n^2) 比较<br>О(1) 交换      	| O(n^2) 比较<br>О(n) 交换 	| O(1) 辅助空间               	|          	|
| 合并排序 	| O(nlog n)                	| O(nlog n)<br>O(n)自然合并排序 	| O(nlog n)                	| O(n) 辅助空间<br>O(1) 链表  	| 分治思想 	|
|          	|                          	|                               	|                          	|                             	|          	|

## 总结

## 参考
- Wikipedia 排序相关
- 归并排序go实现 https://emacsist.github.io/2016/11/22/golang-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8Fmergesort/ 