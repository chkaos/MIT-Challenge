# Sorting Algorithms

#### 冒泡排序

冒泡排序又称为泡式排序，是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

```go
func bubbleSort(L []int) {
	var n = len(L)
	for i := 0; i < n; i++ {
		for j := 0; j < n - 1 - i; j++ {
			if L[j] > L[j+1] {
				swap(L, j, j+1)
			}
		}
	}
}
```
1 次这样的循环可以得到一个最大值, 我们可以通过在每次循环中记录最后的交换的位置(pos)以及双向冒泡来进行性能优化。

```go
func bubbleSort2(L []int) []int {
	start := 0
	end := len(L) - 1
	for start < end {
		var startPos, endPos int
		for i := start; i < end; i++ {
			if L[i] > L[i+1] {
				endPos := i
				swap(L, i, i+1)
			}
		}

		for j := end; j < end; j-- {
			if L[j] > L[j-1] {
				startPos := j
				swap(L, j, j-1)
			}
		}

		start := startPos
	}
	return L
}
```

`This simple algorithm performs poorly in real world use and is used primarily as an educational tool.` 

冒泡排序是一个稳定的排序算法，时间复杂度 O(n²), 交换 O(n²)， 不过任何优化也改变不了这是一个教育级算法的事实...

#### 选择排序

选择排序是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。

```go
func selectionSort(L []int) {
	var n = len(L)
	for i := 0; i < n; i++ {
		var minIdx = i
		for j := i + 1; j < n; j++ {
			if L[j] < L[minIdx] {
				minIdx = j
			}
		}
		swap(L, j, minIdx)
	}
}
```
选择排序的交换操作介于0和`(n-1)`次之间。选择排序的比较操作为`n(n-1)/2}n(n-1)/2`次。选择排序的赋值操作介于`0`和`3(n-1)}3(n-1)`次之间。

比较次数`O(n^{2})`，比较次数与关键字的初始状态无关，总的比较次数`(n-1)/2}N=(n-1)+(n-2)+...+1=n\times (n-1)/2`。交换次数`O(n)`，最好情况是，已经有序，交换0次；最坏情况是，逆序，交换n-1次。交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。

> 原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。

#### 归并排序
- 分割: 递归地把当前数组平均分割成两半
- 集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）

归并排序使用分而治之的思想，以折半的方式来递归/迭代排序元素，利用空间(存储分隔的数组)来换时间，做到了时间复杂度 `O(n·log(n))` 的同时保持了稳定.

这让它在一些更考虑排序效率和稳定性，次考虑存储空间的场合非常适用（如数据库内排序）。和堆排序相比有同样的时间复杂度, 但是堆排序的O(1)辅助空间显然更胜一筹, 但是归并排序的稳定是优点, 且归并排序非常适合于链表排序。

```go
func mergeSort(L []int) []int {
	if len(L) <= 1 {
		return L
	}
	//递[归]
	middle := len(L) / 2
	//不断地进行左右对半划分
	left := mergeSort(L[:middle])
	right := mergeSort(L[middle:])
	//合[并]
	return merge(left, right)
}

func merge(left, right []int) []int{
	newArr := make([]int, len(left)+len(right))
	i, j, index :=0,0,0
	for {
		if left[i] > right[j] {
			newArr[index] = right[j]
			index++
			j++
			if j == len(right) {
				copy(newArr[index:], left[i:])
				break
			}

		}else{
			newArr[index] = left[i]
			index++
			i++
			if i == len(left) {
				copy(newArr[index:], right[j:])
				break
			}
		}
	}
	return newArr
}
```

传入排序方法版本的归并排序, 由于Go语言不支持默认参数, 所以实现起来会有点不优雅, 暂且用参数 struct 来实现默认排序方法

```go
type MergeConf struct {
	L       []int
	Compare func(int, int) bool
}

func mergeSort2(conf MergeConf) []int {
	if len(conf.L) <= 1 {
		return conf.L
	}

	if conf.Compare == nil {
		conf.Compare = func(a, b int) bool {
			return a > b
		}
	}
	//递[归]
	middle := len(conf.L) / 2
	//不断地进行左右对半划分
	leftConf := MergeConf{L: conf.L[:middle], Compare: conf.Compare}
	rightConf := MergeConf{L: conf.L[middle:], Compare: conf.Compare}
	left := mergeSort2(leftConf)
	right := mergeSort2(rightConf)
	//合[并]
	return merge2(left, right, conf.Compare)
}

func merge2(left, right []int, compare func(int, int) bool) []int {
	newArr := make([]int, len(left)+len(right))
	i, j, index := 0, 0, 0
	for {
		if compare(left[i], right[j]) {
			newArr[index] = right[j]
			index++
			j++
			if j == len(right) {
				copy(newArr[index:], left[i:])
				break
			}

		} else {
			newArr[index] = left[i]
			index++
			i++
			if i == len(left) {
				copy(newArr[index:], right[j:])
				break
			}
		}
	}
	return newArr
}
```

#### 快速排序

```go
func quickSort(L []int) {
	// var n = len(L)
	// for i := 0; i < n; i++ {
	// 	for j := 0; j < n - 1 - i; j++ {
	// 		if L[j] > L[j+1] {
	// 			swap(L, j, j+1)
	// 		}
	// 	}
	// }
}
```

#### 插入排序
定位上与选择排序非常相似, 是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列第二位起固定一个指针，和已排序序列最后一位开始比较，一直和前一位交换位置直到若比当前元素小则停止，以此类推，直到所有元素均排序完毕。

稳定, 适合场景：对快要排序完成的数组时间复杂度为 O(n), 非常低的开销

~~~go
func insertionSort(L []int) {
	var n = len(L)
	for i := 1; i < n; i++ {
		j := i
		for j > 0 {
			if L[j-1] > L[j] {
				swap(L, j-1, j)
			}
			j = j - 1
		}
	}
}

// 插入排序的比较是向已排序的数组找一个合适的位置， 用二分法直接找到插入点可以将这一步骤的复杂度变为O(lgN)
// version2
func insertionSort2(L []int) {
	var n = len(L)
	for i := 1; i < n; i++ {
		j := i
		insertIndex := searchInsert(L[:j], L[i])
		for j > insertIndex {
			swap(L, j-1, j)
			j = j - 1
		}
	}
}
~~~

#### 希尔排序

#### 堆排序

## 排序算法比较

|          	| worst-case               	| best case                     	| Average                  	| Worst-case space complexity 	| 特点     	|
|----------	|--------------------------	|-------------------------------	|--------------------------	|-----------------------------	|----------	|
| 冒泡排序 	| O(n^2) 比较<br>О(n^2) 交换 	| O(n^2) 比较<br>О(1) 交换      	| O(n^2) 比较<br>О(n^2) 交换 	| O(1) 辅助空间(证明是in-place sort)              	|    排列一个几乎快排好的数组时间复杂度为O(n)      	|
| 选择排序 	| O(n^2) 比较<br>О(n) 交换 	| O(n^2) 比较<br>О(1) 交换      	| O(n^2) 比较<br>О(n) 交换 	| O(1) 辅助空间(证明是in-place sort)              	|  由于交换复杂度为稳定的O(n), 在特定应用上交换操作消耗比较大时可以选择        	|
| 插入排序 	| O(n^2) 比较<br>О(n^2) 交换 	| O(n^2) 比较<br>О(n^2) 交换      	| O(n^2) 比较<br>О(n) 交换 	| O(1) 辅助空间<br>О(n) total               	| 用二分查找可以优化比较复杂度至 (log n)          	|
| 合并排序 	| O(nlog n)                	| O(nlog n)<br>O(n)自然合并排序 	| O(nlog n)                	| O(n) 辅助空间<br>O(1) 链表  	| 分治思想 	|
| 快速排序 	| O(n^2) 比较<br>О(n) 交换 	| O(n^2) 比较<br>О(1) 交换      	| O(n^2) 比较<br>О(n) 交换 	| O(1) 辅助空间(证明是in-place sort)              	|          	|

## 总结

## 辅助方法
~~~go
// 交换元素位置
func swap(a []int, i, j int) {
	a[i], a[j] = a[j], a[i]
}

// 查找插入位置
func searchInsert(nums []int, target int) int {
	l, r := 0, len(nums)-1
	for l <= r {
		mid := l + (r-l)/2
		if nums[mid] < target {
			l = mid + 1
		} else if nums[mid] > target {
			r = mid - 1
		} else {
			return mid
		}
	}
	return l
}
~~~

## 参考
- Wikipedia 排序相关
- 归并排序go实现 https://emacsist.github.io/2016/11/22/golang-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8Fmergesort/ 