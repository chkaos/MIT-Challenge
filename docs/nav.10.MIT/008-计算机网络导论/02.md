# 2. Transport 传输层

## TCP (Transmission control protocol)

是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能。用户数据报协议（UDP）是同一层内另一个重要的传输协议。

在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。

应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分割成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传给IP层，由它来透过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认信息（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失并进行重传。TCP用一个校验和函数来检验数据是否有错误，在发送和接收时都要计算校验和。

### 3次握手, 4次挥手

所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。

三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。

第一次握手(SYN=1, seq=x):
客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。

发送完毕后，客户端进入 SYN_SEND 状态。

第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):

服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。

第三次握手(ACK=1，ACKnum=y+1)

客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1

发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。

三次握手的过程的示意图如下：

![IPV4数据报结构](~@assets/80/tcp-connection-made-three-way-handshake.png)

TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。

第一次挥手(FIN=1，seq=x)

假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。

发送完毕后，客户端进入 FIN_WAIT_1 状态。

第二次挥手(ACK=1，ACKnum=x+1)

服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。

发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。

第三次挥手(FIN=1，seq=y)

服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。

发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。

第四次挥手(ACK=1，ACKnum=y+1)

客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。

服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。

客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。

四次挥手的示意图如下：

![](~@assets/80/tcp-connection-closed-four-way-handshake.png)

参考: <https://hit-alibaba.github.io/interview/basic/network/TCP.html>

### TCP Service Model
- 字节流: 可靠字节传输服务
- 可靠传输:
  1. 确认正确的传输
  2. `校验和`检测被污染数据
  3. 序列号检测丢失数据
  4. 流量控制防止接收器过度运行 flow control prevents over running receiver: 接收者会持续告诉发送者有无Buffer接收数据
- 数据按顺序传送到应用程序
- congestion 控制: 网络堵塞控制

![](~@assets/80/tcp_segment.png)

TCP连接独一无二的ID
- 保证客户端使用了唯一的端口
- TCP picks ISN to avoid overlap with previous connection with same ID
  1. 生成随机的序列数

其他
- 基于窗口的流控制
- Retransmission and timeouts 重传和超时
- 网络堵塞控制

### UDP Service Model
UDP 是一个简单的面向数据报的通信协议，位于OSI模型的传输层。该协议由David P. Reed在1980年设计且在RFC 768中被规范。典型网络上的众多使用UDP协议的关键应用在一定程度上是相似的。

在TCP/IP模型中，UDP为网络层以上和应用层以下提供了一个简单的接口。UDP只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以UDP有时候也被认为是不可靠的数据报协议）。UDP在IP数据报的头部仅仅加入了复用和数据校验字段。

![UDP数据报格式](~@assets/80/udp_datagram.png)

UDP数据包的头部只包含来源及目标端口， checksum 和长度，因此header数据量较TCP要少;

- 无连接型数据报服务
  1. 不建立双方连接
  2. 无序的数据包, 可能以任意顺序接受
- self-contained datagrams
- 不可靠的传输
  1. 客户端与服务器无复杂的确认步骤
  2. 无检测丢失及错误数据报的机制
  3. 无流控制

#### 使用UDP的一些系统
域名系統（英語：Domain Name System，縮寫：DNS）是互联网的一项服务。 它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。

动态主机设置协议（英语：Dynamic Host Configuration Protocol，缩写：DHCP），又称动态主机组态协定，是一个用于IP网络的网络协议，位于OSI模型的应用层，使用DHCP协议工作，主要用于内部网或网络服务供应商自动分配IP地址给用户或内部网管理员对所有电脑作中央管理;

网络时间协议（英語：Network Time Protocol，缩写：NTP）是在数据网络潜伏时间可变的计算机系统之间通过分组交换进行时钟同步的一个网络协议，可以使计算机对其服务器或时钟源（如石英钟，GPS等等)做同步化，它可以提供高精准度的时间校正（LAN上与标准间差小于1毫秒，WAN上几十毫秒），且可介由加密确认的方式来防止恶毒的协议攻击。NTP的目的是在无序的Internet环境中提供精确和健壮的时间服务。

但现代视频流多用 TCP 而不是 UDP;

### ICMP Service Model

IP 协议的助手，为 IP 协议提供相关的故障诊断和控制信息，

ICMP(互联网控制消息协议)是互联网协议族的核心协议之一, 位于传输层. 它用于网际协议中发送控制消息，提供可能发生在通信环境中的各种问题反馈。通过这些信息，使管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。 ICMP 依靠IP来完成它的任务，它是IP的主要部分。它与传输协议显著不同：它一般不用于在两点间传输数据。

- 报错
- 不可靠: 简单数据报服务, 无重试机制

#### ICMP类型细分表(部分)

~[](~@assets/80/ICMP_MSG.png)

#### ping
ping是一种计算机网络工具，用来测试数据包能否透过IP协议到达特定主机。ping的运作原理是向目标主机传出一个ICMP的请求回显数据包，并等待接收回显回应数据包。程序会按时间和成功响应的次数估算丢失数据包率和数据包往返时间。

#### traceroute
现代Linux系统称为tracepath，Windows系统称为tracert，是一种电脑网络工具。它可显示数据包在IP网络经过的路由器的IP地址

#### 其他
常见的 ICMP 攻击是 ICMP 泛洪攻击，这是一种 DDoS 攻击。简单说就是攻击者向一个子网的的广播地址发送多个 ICMP echo 包，包的源地址伪装成他想要攻击的目的主机的 IP，然后该子网的所有主机的 ICMP reply 包都会送到被攻击主机，该主机瞬时收到大量的 ICMP 回复包，消耗大量资源，来不及处理，便会进入瘫痪或无法提供正常服务。

解决 ICMP 泛洪攻击最简单的方法就是禁 ping 了。

## 端到端原则 - 网络设计原则(也是分布式系统设计原则之一)
端到端原则是一种分布式系统中各模块间功能定位的设计原理，指从代价和性能的角度分析，在网络的最核心的部分应该只做数据的传输而不能去做一些其他的应用，而数据是否正确传输则应该放到应用层去检查和判断，从而保证互联网核心的简单性、可维护性和可扩展性。

比如: 
- 数据压缩
- 格式化/翻译/优化 请求
- 数据缓存
- 提高安全性
- 网络连接转移
- 其他

### 例子

File Transfer 文件传输校验
Link Reliability 链接可靠度

数据传输的可靠性是通过数据链路层和网络层的点对点和传输层的端对端保证的。端到端与点到点是针对网络中传输的两端设备间的关系而言的。

#### 端到端通信

端到端通信是针对传输层来说的，它是一个网络连接，指的是在数据传输之前，在发送端与接收端之间（忽略中间有多少设备）为数据的传输建立一条链路，链路建立以后，发送端就可以发送数据，知道数据发送完毕，接收端确认接收成功。 也就是说在数据传输之前，先为数据的传输开辟一条通道，然后在进行传输。从发送端发出数据到接收端接收完毕，结束。

优点：
链路建立之后，发送端知道接收端一定能收到，而且经过中间交换设备时不需要进行存储转发，因此传输延迟小。

缺点：
（1）直到接收端收到数据为止，发送端的设备一直要参与传输。如果整个传输的延迟很长，那么对发送端的设备造成很大的浪费。
（2）如果接收设备关机或故障，那么端到端传输不可能实现。

#### 点到点通信
点到点通信是针对数据链路层或网络层来说的，点对点是基于MAC地址和或者IP地址，是指一个设备发数据给与该这边直接连接的其他设备，这台设备又在合适的时候将数据传递给与它相连的下一个设备，通过一台一台直接相连的设备把数据传递到接收端。

点到点的优点：
（1）发送端设备送出数据后，它的任务已经完成，不需要参与整个传输过程，这样不会浪费发送端设备的资源。

（2）即使接收端设备关机或故障，点到点传输也可以采用存储转发技术进行缓冲。

点到点的缺点：
点到点传输的缺点是发送端发出数据后，不知道接收端能否收到或何时能收到数据。

在一个网络系统的不同分层中，可能用到端到端传输，也可能用到点到点传输。如Internet网，IP及以下各层采用点到点传输，4层以上采用端到端传输。

## 错误检查
- ethernet CRC, TLS MAC
- IP checksum

CRC: (循环冗余校验/Cyclic redundancy check): 是一种根据网络数据包或电脑文件等数据产生简短固定位数校验码的一种散列函数，主要用来检测或校验数据传输或者保存后可能出现的错误。生成的数字在传输或者存储之前计算出来并且附加到数据后面，然后接收方进行检验确定数据是否发生变化。由于本函数易于用二进制的电脑硬件使用、容易进行数学分析并且尤其善于检测传输通道干扰引起的错误，因此获得广泛应用。

TLS: 传输层安全性协议（英语：Transport Layer Security，缩写：TLS）及其前身安全套接层（英语：Secure Sockets Layer，缩写：SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障目前已成为互联网上保密通信的工业标准。SSL包含记录层（Record Layer）和传输层，记录层协议确定传输层数据的封装格式。传输层安全协议使用X.509认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）。这个会谈密钥是用来将通信两方交换的资料做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。

校验和: （英语：Checksum）是冗余校验的一种形式。 它是通过错误检测方法，对经过空间（如通信）或时间（如计算机存储）所传送数据的完整性进行检查的一种简单方法。



### 错误解决方案比较

#### IP CheckSum

1. IP, UDP, TCP使用"一的补码"(将二进制数每个数字反转，得到的数即为原二进制的一的补码) CheckSum 算法
  发送IP数据报计算checksum: 
  - 先将需要计算checksum数据中的checksum设为0； 
  - 计算checksum的数据按2byte划分开来，每2byte组成一个16bit的值，如果最后有单个byte的数据，补一个byte的0组成2byte；   
  - 将所有的16bit值累加到一个32bit的值中； 
  - 将32bit值的高16bit与低16bit相加到一个新的32bit值中，若新的32bit值大于0Xffff, 
再将新值的高16bit与低16bit相加； 
  - 将上一步计算所得的16bit值按位取反，即得到checksum值，存入数据的checksum字段即可。

2. 优点: 快, 容易计算及校验, 来源于最早软件实施
3. 缺点: 只能保证检测单字节错误, 理论上可以检测出其他错误, 实际上该保证弱且复杂

#### Cyclic redundancy check

循环冗余校验/Cyclic redundancy check

CRC为校验和的一种，是两个字节数据流采用二进制除法（没有进位，使用XOR来代替减法）相除所得到的余数。其中被除数是需要计算校验和的信息数据流的二进制表示；除数是一个长度为(n+1)的预定义（短）的二进制数，通常用多项式的系数来表示。在做除法之前，要在信息数据之后先加上n个0

1. 计算成本相对Checksum较高(不包括硬件层面), 可检测任何 2 bits 错误, c (核验多项式)bits errors, 奇数 bits errors
2. 链路层使用

#### MAC Message authentication code

消息认证码: (Message authentication code)，又译为消息鉴别码、文件消息认证码、讯息鉴别码、信息认证码，是经过特定算法后产生的一小段信息，检查某段消息的完整性，以及作身份验证。它可以用来检查在消息传递过程中，其内容是否被更改过，不管更改的原因是来自意外或是蓄意攻击。同时可以作为消息来源的身份验证，确认消息的来源。

s: 密钥
c 为密码学生成的小于M长度的数;

- TLS(传输层使用): 对于恶意修改具有足够健壮性, 但不报错, 任意两条消息有 2的负C次方概率消息认证码重复
- 错误检测能力不及 CRC

## 有限状态机在TCP里的应用

### Http Request
![http请求例子](~@assets/80/fsm.jpg)

## flow control(stop and wait) 流控

存在问题: sender每秒发送的数据包数量超过, receiver可接收的数量;

  - 确保发送者不要发送超过接收者可处理的量
  - 接收者提供反馈
  - 两种基本解决方法( Stop and wait/Sliding window)

### [Stop and wait](https://www.geeksforgeeks.org/stop-and-wait-arq/)

1. Used in Connection-oriented communication
2. 任意时间内只允许一个数据包传输
3. Sender 发送一个数据包

~[](~@assets/80/sender&receiver.jpg)

检测重复请求
- 使用 1字节计数器: 接收方可以知道是否为新数据或重复数据


### Sliding window

相当于广义化的 Stop and wait: 允许N个确认切片存在

滑动窗口协议（Sliding Window Protocol），属于TCP协议的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认。因此该协议可以加速数据的传输，提高网络吞吐量。

TCP滑动窗口分为接受窗口，发送窗口是传输层进行流控的一种措施。接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。(https://zh.wikipedia.org/wiki/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6)

#### 发送方:
- 每个发送片段拥有一个序列号
- 维护三个变量
  - Send window size(SWS)
  - Last acknowledgement received (LAR)
  - Last segment sent(LSS)
- Sender 维护的不变式 (LSS-LAR) <= SWS
- 接收到 ACK 信号更新 LAR
- 缓冲至SWS片段

问题: 发送窗口如果前面片段未收到ack信号, 会使窗口停止滑动

#### 接收方
- 维护三个变量
  - Receive window size(RWS)
  - Last acceptable segment (LAS, 如果LAS为3则代表3及之前的片段全部接收完毕)
  - Last segment received(LSR)
- Receiver 维护的不变式 (LAS-LSR) <= RWS
- 如果接收到包 < LAS, 则发送 ack
  - 发送累计ack例子: 接收到 1,2,3,5 则发送3,  4之后会累积到下一轮(解决上面的问题)

#### RWS, SWS 和序列空间
- RWS >=1, SWS >=1, RWS<=SWS
- 一搬来说 序列空间需要数字为 RWS + SWS


### 重传策略
快速重传: 每个数据包在发送时会创建一个对应的重传计时器, 如果没能在特定时间内接收到相应分段的确认，发送方就假设这个分段在网络上丢失了，需要重发

主流的重传策略有两种:
- "go back N": 一个包丢失会重传整个窗口(悲观主义)
- "Selective repeat"选择性重复: 只重传丢失的数据包(乐观主义)

由于“滑动窗口”协议的性能取决于窗口大小和网络接收数据包的速度，在流量不稳定的环境中，性能下降甚至可能会使网络发生冲突。 为了避免和提供端到端流量控制，可以建议“慢启动”协议(主要集中在如何减少TCP报文重传方面)。